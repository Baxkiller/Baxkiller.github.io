<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/ico.ico >
    <title>
        Blog | Baxkiller
    </title>
    <meta name="description" content= Hey Bro! Here's Baxkiller's Blog Site. >
    <meta name="keywords" content= Blog,Hexo,Theme,Baxkiller,Coder >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            CSA_Review
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="第二章-指令系统"><a href="#第二章-指令系统" class="headerlink" title="第二章  指令系统"></a>第二章  指令系统</h1><blockquote>
<p>数据表示，数据类型</p>
<p>采用标识符数据表示的优点？（三简化，硬件(一致性检查，数据类型转换)，软件，数据库）缺点？（三个，数据，指令，硬件）</p>
<p>标识符数据表示与数据描述符描述的差别？</p>
<p>浮点数表示rm增大，带来的影响（6个）；</p>
<p>尾数下溢的处理方法（4种），各自的优缺点</p>
<p>编址方式（4种），对齐方式，大小端；高位/低位交叉编址；寻址方式（四种）</p>
<p>定位方式（3），各自的含义，为什么要定位（4）</p>
<p>操作码设计（3种），信息冗余度计算</p>
<p>RISC基本思想（定义/目的），RISC特点（指令（4），硬，优化编译）</p>
<p>RISC关键技术（延时转移，指令取消，寄存器窗口重叠，指令流调整技术，高速缓冲寄存器Cache，优化设计编译系统；）</p>
</blockquote>
<h2 id="数据表示与数据类型的定义和区别"><a href="#数据表示与数据类型的定义和区别" class="headerlink" title="数据表示与数据类型的定义和区别"></a>数据表示与数据类型的定义和区别</h2><ul>
<li><p>数据表示</p>
<p>是指计算机硬件能够直接识别，可以被指令系统直接调用的那些<strong>数据类型</strong>。</p>
</li>
<li><p>数据结构</p>
<p>反映了应用中要用到的各种数据元素或信息单位之间的结构关系。数据结构要通过软件映像，变换成机器所具有的数据表示来实现。不同的数据表示可为数据结构的实现提供不同的支持。</p>
</li>
<li><p>数据类型</p>
<p>确定哪些数据类型用数据表示来实现的<strong>原则</strong></p>
<ul>
<li><p>缩短程序的运行时间</p>
</li>
<li><p>减少CPU与主存储器之间的通信量</p>
</li>
<li><p>这种数据表示的通用性和利用率</p>
</li>
</ul>
</li>
</ul>
<h2 id="标志符数据表示-数据描述符"><a href="#标志符数据表示-数据描述符" class="headerlink" title="标志符数据表示,数据描述符"></a>标志符数据表示,数据描述符</h2><h3 id="标志符数据表示"><a href="#标志符数据表示" class="headerlink" title="标志符数据表示"></a>标志符数据表示</h3><ul>
<li><p>一般的计算机中，数据存储单元(寄存器、主存储器、外存储器等)只存放纯数据，数据的属性<strong>通过指令中的操作码来解释</strong>：数据的类型，进位制，数据字长，寻址方式，数据的功能；</p>
<p>这使得同一种操作（例如加法）通常有很多条指令。</p>
</li>
<li><p><strong>对应改进：</strong></p>
<p>添加<strong>类型标志位/标志符</strong>，用来描述对应数据的属性。这个标志符由编译器或者其他系统软件建立，对程序员透明。这会使得数据的存储量增加，指令的存储量减少。</p>
</li>
</ul>
<p>==<strong>采用标志符数据表示方法的优点：</strong>==</p>
<ol>
<li><p>简化了指令系统。</p>
</li>
<li><p>由硬件实现一致性检查和数据类型转换。</p>
</li>
<li><p>简化程序设计，缩小了人与计算机之间的语义差距。</p>
</li>
<li><p>简化编译器，使高级语言与机器语言之间的语义差距大大缩短。</p>
</li>
<li><p>支持数据库系统，一个软件不加修改就可适用于多种数据类型。</p>
</li>
<li><p>方便软件调试，在每个数据中都有陷井位。</p>
</li>
</ol>
<p>==主要缺点：==</p>
<ol>
<li><p>数据和指令的长度可能不一致</p>
<p>可以通过精心设计指令系统来解决。 </p>
</li>
<li><p>指令的执行速度降低</p>
<p>但是，程序的运行时间是由设计时间、编译时间和调试时间共同组成的。</p>
<p>采用标志符数据表示方法，程序的设计时间、编译时间和调试时间可以缩短。</p>
</li>
<li><p>硬件复杂度增加</p>
<p>由硬件实现一致性检查和数据类型的转换。</p>
</li>
</ol>
<h3 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h3><p>对于一列数据进行相同的操作,它们具有共同的特征或者说标志。</p>
<ul>
<li>定义：为进一步减少标志符所占用的存储空间，对向量、数据、记录等数据，由于元素属性<strong>相同</strong>，采用数据描述符。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>标志符只作用于一个数据，而数据描述符要作用于一组数据。 </p>
<h2 id="浮点数的表示方法"><a href="#浮点数的表示方法" class="headerlink" title="浮点数的表示方法"></a>浮点数的表示方法</h2><img src="https://s2.loli.net/2022/06/25/hARL2ZQlBD31GdW.png" alt="image-20220624214820583" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/25/38gvFuTnhN6IGVm.png" alt="image-20220624215146422" style="zoom:90%;" />

<h3 id="变化特征"><a href="#变化特征" class="headerlink" title="变化特征"></a>变化特征</h3><p>随着$r_m$的增大，可以表示的最小值减小，可以表示的最大值增大，也就是</p>
<ul>
<li>可以表示的数的范围增大了。</li>
<li>可以表示的数的个数增大了。</li>
<li>在$r_m=2$的浮点数相重叠的范围内，数的密度分布越稀疏</li>
<li>表示的数据精度下降</li>
<li>运算中的精度损失减小（因为对阶移位的机会和次数减少，书的表示范围扩大，导致尾数溢出的右规机会减少）</li>
<li>运算速度提高(理由同上,由于减少了右规次数,而提高了运算速度)</li>
</ul>
<img src="https://s2.loli.net/2022/06/25/FCbfIhaXWr8lQJc.png" alt="image-20220624221940586" style="zoom:80%;" />

<h3 id="尾数下溢的处理方法"><a href="#尾数下溢的处理方法" class="headerlink" title="尾数下溢的处理方法"></a>尾数下溢的处理方法</h3><p>注意每种方法的<strong>误差计算</strong></p>
<ol>
<li><p>截断法，直接抛弃</p>
<p>优点：实现简单，不需要增加硬件，不需要处理时间。</p>
<p>缺点：误差较大，无法调节</p>
</li>
<li><p>舍入法，四舍五入</p>
<p>在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1。</p>
<p>优点：实现简单，增加硬件少，最大误差小，平均误差为0.</p>
<p>缺点：处理速度慢，需要花费在附加位上加1以及因此产生的进位时间。</p>
</li>
<li><p>恒置“1”法</p>
<p>将有效字长的最低一个位置，设置为$r_m/2$</p>
<p>优点：实现简单，不需要增加硬件和处理时间，平均误差接近0</p>
<p>缺点：最大误差比较大</p>
</li>
<li><p>查表舍入法</p>
<p>用ROM或者PLA存放下溢处理表。</p>
<p>优点：速度快，平均误差可以调节到0</p>
<p>缺点：硬件量大</p>
</li>
</ol>
<img src="https://s2.loli.net/2022/06/25/NWDJv4hPClMjRz8.png" alt="image-20220625004836952" style="zoom:80%;" />



<h2 id="基本的编址方式-寻址方式和定位方式"><a href="#基本的编址方式-寻址方式和定位方式" class="headerlink" title="基本的编址方式,寻址方式和定位方式"></a>基本的编址方式,寻址方式和定位方式</h2><h3 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h3><p>常见的有位编址,字节编址,字编址,块编址</p>
<ul>
<li><p>字节编址,字访问</p>
<p>按照每个字节都有一个地址,但是访问的时候一次访问一个字。</p>
<p>优点：有利于符号处理</p>
<p>缺点：</p>
<ul>
<li>地址信息浪费（32位机，每个字对应4个字节，也就是最后2位被浪费；64位机，每个字对应8个字节，最后3位被浪费</li>
<li>存储器空间浪费</li>
<li>读写逻辑复杂</li>
<li>大端小端问题</li>
</ul>
</li>
<li><p>数据对齐访问：</p>
<ul>
<li><p>从任意位置都可访问</p>
<p>优点：节省存储资源</p>
<p>缺点：地址信息浪费，降低了读写速度，读写控制逻辑复杂</p>
</li>
<li><p>从一个存储字的起始位置开始访问</p>
<p>优点：读写速度快，控制逻辑简单</p>
<p>缺点：地址信息浪费，存储资源浪费</p>
</li>
<li><p>从地址的整倍数位置开始访问</p>
<p>优点：速度快，无论哪种访问都可以在一个周期内完成</p>
<p>缺点：一定程度上浪费了存储器资源，控制逻辑仍然比较复杂</p>
</li>
</ul>
</li>
<li><p>大小端问题</p>
<p>地址存储时一定是从低位地址递增向高位地址存储。</p>
<ul>
<li>大端（高尾端）：数据的高位字节存储到低地址，例如(12 | 34 | 56 | 78 )，地址从左到右递增</li>
<li>小端（低尾端）：数据的高位字节存储到高位地址，例如（78 | 56 | 34 | 12）地址从左到右递增</li>
</ul>
</li>
</ul>
<p><strong>编址之独立编址：零地址空间的个数</strong></p>
<p>通用寄存器，主存，输入输出设备</p>
<ol>
<li>三个零地址空间：各自独立编址</li>
<li>两个：主存+输入输出，通用寄存器</li>
<li>一个：最低端是通用寄存器，高端是输入输出设备，中间主存</li>
<li>隐含编址：Cache与堆栈</li>
</ol>
<p><strong>交叉编制：高位交叉N/低位交叉Z</strong></p>
<p>给定(i,j)，其中i从0开始，j从0开始，求其所处线性位置；</p>
<p>给定线性位置，求其对应二维位置；</p>
<ul>
<li><p>低位交叉编址（通过低位来区分存储体，因为同一个存储体内的低位都是相同的）</p>
<p>提高读写的速度</p>
<img src="https://s2.loli.net/2022/06/25/hPKdcQnX5AOfrRj.png" alt="image-20220625110219496" style="zoom:67%;" /></li>
<li><p>高位交叉编制（高位来区分存储体，一个存储体填满之后再去填写另一个存储体）</p>
<p>优点：适用于共享存储器的多机系统，适用于指令和数据分别存储在不同的分体中，有利于存储器的扩充</p>
<p>缺点：性能比低位交叉编制差</p>
<img src="https://s2.loli.net/2022/06/25/XMiYA6scQLnNp4O.png" alt="image-20220625110932341" style="zoom:67%;" /></li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>立即数寻址</li>
<li>寄存器寻址（操作数来自寄存器，结果写回寄存器）</li>
<li>面向主存的寻址<ul>
<li>直接寻址</li>
<li>间接寻址</li>
<li>变址寻址（相对寻址，基址寻址）</li>
</ul>
</li>
<li>面向堆栈的寻址（隐含的，指令中不需要给出操作数地址）</li>
</ul>
<h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><p>定义：研究程序的主存物理地址什么时候确定，采用什么方式实现（也就是逻辑地址和物理地址的转换）</p>
<p><strong>程序为啥需要定位？</strong></p>
<ul>
<li>程序的独立性</li>
<li>程序的模块化</li>
<li>数据结构运行过程中大小变化</li>
<li>有些程序本身太大</li>
</ul>
<h4 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h4><p>在程序装入主存储器之前，程序中的指令和数据的主存物理就已经确定了。（一次装入一整个程序，整个系统的地址完全为该程序服务）。</p>
<h4 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h4><p>在程序<strong>装入主存储器的过程</strong>中随即进行地址变换，确定指令和数据的主存物理地址。</p>
<h4 id="动态定位"><a href="#动态定位" class="headerlink" title="动态定位"></a>动态定位</h4><p>在程序<strong>执行过程</strong>中，当<strong>访问到相应的指令或数据时才进行地址变换</strong>，确定指令和数据的主存物理地址。</p>
<p>对应需要增加基址寄存器和地址加法器<strong>硬件</strong>。基址寄存器存储装入程序的起始地址，加法器硬件将基址寄存器内容与逻辑地址相加，形成物理地址。可在指令中加入相应的标志位来指明指令地址是否需要加基址。</p>
<h2 id="操作码优化设计（也就是减少指令长度）"><a href="#操作码优化设计（也就是减少指令长度）" class="headerlink" title="操作码优化设计（也就是减少指令长度）"></a>操作码优化设计（也就是减少指令长度）</h2><p>指令系统优化设计的主要目标是：<strong>节省程序的存储空间</strong>，指令格式尽量规整，便于译码</p>
<blockquote>
<p>对于指令所占内存大小来说，固定长度&gt; 扩展编码&gt; Huffman编码</p>
<p>==<strong>信息冗余量的计算：</strong>==</p>
<p>$R=\frac{当前长度-最短平均长度}{当前长度}$</p>
</blockquote>
<h3 id="固定长操作码"><a href="#固定长操作码" class="headerlink" title="固定长操作码"></a>固定长操作码</h3><p>优点：规整，译码简单</p>
<p>缺点：浪费信息量（操作码总长位数增加）</p>
<h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><p>对发生概率最高的事件用最短的位数（时间）来表示（处理），而对出现概率较低的事件允许使用较长的位数（时间）来表示（处理），使表示（处理）的平均位数（时间）缩短</p>
<p>操作码的==<strong>最短平均长度</strong>==通过公式计算：其中pi代表第i种操作码在程序中出现的概率。</p>
<img src="https://s2.loli.net/2022/06/25/xiWHDnFzA2BaQ4y.png" alt="image-20220625130054037" style="zoom:80%;" />

<p>优点：信息冗余量小</p>
<p>缺点：长度不规整，<strong>译码困难</strong>；与地址码共同组成固定长的指令比较困难。</p>
<h3 id="扩展编码"><a href="#扩展编码" class="headerlink" title="扩展编码"></a>扩展编码</h3><p>长度不是定长，但是只有有限几种码长。仍采用高概率指令短码，低概率指令长码。</p>
<ul>
<li><p>4-8-12等长扩展编码法</p>
<ul>
<li><p>等长15/15/15扩展法</p>
</li>
<li><p>等长8/64/512</p>
<p>每增加4位，都对应只使用这4位的0000-0111，共计8种。留下8种给后面用。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>附带内容：指令字格式的优化</p>
<ol>
<li>扩展编码；2. 多种寻址方式以缩短地址码长度；3. 采用多种地址制；4. 在同种地址制内采用多种地址形式；5.  使用多种不同的指令字长度</li>
</ol>
</blockquote>
<h2 id="RISC-的基本原理和思想、实现的关键技术"><a href="#RISC-的基本原理和思想、实现的关键技术" class="headerlink" title="RISC 的基本原理和思想、实现的关键技术"></a>RISC 的基本原理和思想、实现的关键技术</h2><p>RISC基本思想：通过减少指令种类和简化指令功能来<strong>降低硬件设计的复杂度</strong>，提高指令执行速度</p>
<p>RISC定义与特点：</p>
<ul>
<li>减少指令和寻址方式种类：指令系统只选择高频指令，减少指令数量，一般不超过100条；减少寻址方式，一般<strong>不超过两种</strong></li>
<li>固定指令格式：指令格式限制在两种以内，并使全部指令都在相同的长度</li>
<li>大多数指令在一个时钟周期内完成</li>
<li>采用LOAD/STORE结构：扩大通用寄存器数量（一般不少于32个），尽量减少访存，只有L/S可以访存，其他只对寄存器操作</li>
<li>硬布线逻辑：大多指令采用硬布线逻辑，少数微程序</li>
<li>优化编译：通过精减指令和优化设计编译程序，简单有效地支持高级语言实现</li>
</ul>
<p><strong>RISC思想精华：减少CPI</strong></p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><blockquote>
<p>延时转移，指令取消，寄存器窗口重叠，指令流调整技术，高速缓冲寄存器Cache，优化设计编译系统；</p>
</blockquote>
<ol>
<li><p>延时转移技术：为了流水线不断流，在转移指令后插入一条没有数据相关和控制相关的有效指令，儿转移指令被延迟执行；这一过程由编译器负责。</p>
<p>限制条件：被移动指令与经过的指令无数据相关；被移动指令不破坏条件码；</p>
</li>
<li><p>指令取消技术：分两种情况，向后转移（循环程序）+向前转移（条件指令）</p>
<ul>
<li><p>向后转移：循环体第一条指令安放在两个位置：循环体之前与循环体条件判断之后。<strong>转移成功不取消。</strong>（因为循环，希望其转移成功）</p>
<img src="https://s2.loli.net/2022/06/25/vphOa37Dm9kywMA.png" alt="image-20220625151922521" style="zoom:80%;" /></li>
<li><p>向前转移：<strong>转移成功则取消。</strong>（因为执行的是不成功的指令）</p>
<img src="https://s2.loli.net/2022/06/25/IDWGsefrBz2UXoK.png" alt="image-20220625152111964" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>重叠寄存器窗口技术：设置一个数量比较大的寄存器堆，并把它划分成很多个窗口。 在每个过程使用的几个窗口中：</p>
<ul>
<li>有一个窗口是与前一个过程共用</li>
<li>有个窗口是与下一个过程共用</li>
</ul>
<img src="https://s2.loli.net/2022/06/25/MPZikIfJ6t9Dbas.png" alt="image-20220625152405907" style="zoom:80%;" /></li>
<li><p>指令流调整技术：通过变<strong>量重新命名</strong>消除数据相关，提高流水线效率</p>
</li>
<li><p>采用高速缓冲寄存器Cache：指令Cache和数据Cache</p>
</li>
<li><p>优化设计编译系统：寄存器优化，指令序列调整，子程序库</p>
</li>
</ol>
<h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><blockquote>
</blockquote>
<h2 id="存储系统定义和评价标准（价格、容量和速度）"><a href="#存储系统定义和评价标准（价格、容量和速度）" class="headerlink" title="存储系统定义和评价标准（价格、容量和速度）"></a>存储系统定义和评价标准（价格、容量和速度）</h2><blockquote>
<p>命中率的计算H，访问周期与命中率的关系T，<strong>存储系统的访问效率e</strong></p>
</blockquote>
<p>组成存储系统的关键：将速度，容量，价格不同的多个物理存储器组织成一个存储器，其速度最快，容量最大，<strong>单位容量</strong>价格最便宜。</p>
<h3 id="存储系统的定义"><a href="#存储系统的定义" class="headerlink" title="存储系统的定义"></a>存储系统的定义</h3><p><strong>两个或两个以上速度、容量和价格各不相同的存储器</strong>用硬件、软件、或软件与硬件相结合的方法<strong>连接起来成为一个存储系统。</strong>这个存储系统对程序员透明，并且该存储器速度<strong>接近</strong>速度最快的那个存储器，存储容量与容量最大的那个存储器<strong>相等</strong>，单位容量的价格<strong>接近</strong>最便宜的那个存储器。</p>
<p>一般计算机系统有两种存储系统：<strong>Cache存储系统（Cache与主存）</strong>和<strong>虚拟存储系统（主存与外存）</strong>。前者目的是加快存储器速度，后者为了扩大存储器容量。</p>
<h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><ol>
<li><p>容量：要求提供尽量大的地址空间，可以随机访问</p>
<ul>
<li>只对系统中存储容量大的编址，其他存储器内部编制/不编址（如Cache）</li>
<li>设计容量很大的逻辑空间，将相关存储器都映射到这个大空间（虚拟存储系统）</li>
</ul>
</li>
<li><p>价格：</p>
<p>计算公式：<img src="https://s2.loli.net/2022/06/25/n7yELAp3awzWgXN.png" alt="image-20220625163437857" style="zoom:67%;" /></p>
</li>
<li><p>速度：访问周期/存取周期/存储周期/存取时间/<strong>命中率</strong></p>
<ul>
<li><p>在一轮存储器访问过程中，命中率在M1存储器访问到的概率<img src="https://s2.loli.net/2022/06/25/651eMplO9kgT84c.png" alt="image-20220625163634133" style="zoom: 80%;" /></p>
</li>
<li><p><strong>访问周期与命中率的关系</strong></p>
<p>$$<br>T=H \cdot T_1+(1+H)\cdot T_2<br>$$<br>当命中率趋近于1，T趋近于T1</p>
</li>
<li><p><strong>存储系统的访问效率</strong>（与命中率和两级存储器的速度之比有关系）</p>
<img src="https://s2.loli.net/2022/06/25/E7FoKXvt4g6ILAQ.png" alt="image-20220625165802130" style="zoom:80%;" />

<p>关系图：</p>
<ul>
<li><strong>当r过大时</strong>,<strong>前期提高命中率对整个存储系统的效率提升不大</strong></li>
<li>提高存储系统访问效率的方法：提高命中率H，两个存储器的速度相差不要太大。</li>
<li><img src="https://s2.loli.net/2022/06/25/H2OyZsqiwmCr89Q.png" alt="image-20220625170145564" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h2><p>多层次寄存器：寄存器堆，先行缓冲站，高速缓冲存储器Cache，主存，联机存储器，脱机存储器</p>
<h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><p>指的是将原本m字w位的存储器改变成为m/n字n*w位的存储器。</p>
<h2 id="交叉访问存储器"><a href="#交叉访问存储器" class="headerlink" title="交叉访问存储器"></a>交叉访问存储器</h2><h2 id="虚拟存储器工作原理（页，段，段页式）"><a href="#虚拟存储器工作原理（页，段，段页式）" class="headerlink" title="虚拟存储器工作原理（页，段，段页式）"></a>虚拟存储器工作原理（页，段，段页式）</h2><h2 id="加快内部地址变换的方法"><a href="#加快内部地址变换的方法" class="headerlink" title="加快内部地址变换的方法"></a>加快内部地址变换的方法</h2><h2 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h2><h2 id="页面大小，主存容量，页面调度算法对主存命中率影响"><a href="#页面大小，主存容量，页面调度算法对主存命中率影响" class="headerlink" title="页面大小，主存容量，页面调度算法对主存命中率影响"></a>页面大小，主存容量，页面调度算法对主存命中率影响</h2><h2 id="Cache存储系统基本工作原理"><a href="#Cache存储系统基本工作原理" class="headerlink" title="Cache存储系统基本工作原理"></a>Cache存储系统基本工作原理</h2><h3 id="直接映像"><a href="#直接映像" class="headerlink" title="直接映像"></a>直接映像</h3><h3 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h3><h3 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h3><h2 id="Cache的一致性问题"><a href="#Cache的一致性问题" class="headerlink" title="Cache的一致性问题"></a>Cache的一致性问题</h2><h2 id="Cache的预取算法"><a href="#Cache的预取算法" class="headerlink" title="Cache的预取算法"></a>Cache的预取算法</h2>
    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <p><h4>© 2021 Baxkiller Powered By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="db91ONAaJE7csgIBIIeWxEXK-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="V4ivekKhnC8pvzwTKL40Pnx8">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
