<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/ico.ico >
    <title>
        Blog | Baxkiller
    </title>
    <meta name="description" content= Hey Bro! Here's Baxkiller's Blog Site. >
    <meta name="keywords" content= Blog,Hexo,Theme,Baxkiller,Coder >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Compile_Principle_Review
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="概念题-不考"><a href="#概念题-不考" class="headerlink" title="概念题(不考"></a>概念题(不考</h2><ul>
<li><p><input disabled="" type="checkbox">  什么是编译程序</p>
<p>翻译程序:</p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  表达式得形成规则</p>
<p>➢ 变量（包括下标变量）、常数是<strong>表达式</strong>；</p>
<p>➢ 若E1、E2为表达式，θ是一个二元算符，则$E_1\ θ\ E_2$是一个表达式；</p>
<p>➢ 若E是表达式，θ为一元算符，则$θE（或Eθ）$是表达式；</p>
<p>➢ 若E是表达式，则(E)是表达式。</p>
</li>
<li><p><input disabled="" type="checkbox">  运算顺序和结合性(关于<strong>运算符优先级</strong>的知识)</p>
</li>
<li><p><strong>闭包</strong></p>
<p>某个符号串的闭包运算规则是,但是经过的是有限次的链接而成的,也就是闭包中的每个字符串的长度有限.<br>$$<br>V^{<em>}=V^{0} \or V^{1} \or V^{2} \or V^{3} \or \cdots<br>$$<br><strong>正则闭包</strong><br>$$<br>V^{+}=VV^{</em>}<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  关于空集与空字的区分!</p>
<p>空集,即$\varnothing$,代表的是${}$,是集合</p>
<p>空字,用$\epsilon$表示,代表的是不含有任何符号的序列,是一个集合中的元素</p>
<p>而${\epsilon}$往往用来代表某个符号串的0次连接积,也就是$V^{0}$</p>
</li>
</ul>
<ul>
<li><p><strong>关于推导</strong></p>
<p>最右推导: 推导过程中,总是最先替换最右的非终结符,称之为<strong>最右推导</strong></p>
<p>最右规约:规约时,总是最先规约最右的非终结符,称之为最右规约.</p>
<p><strong>规范推导(最右推导)</strong></p>
<p><strong>规范规约(最左规约)</strong></p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  知道常见的状态转换图</p>
</li>
<li><p><input disabled="" type="checkbox">  正规式之间的运算规则以及常见的等价正规式</p>
<ul>
<li><p>等价的正规式    </p>
<p>例如比较常见的是b(a|b)^<em>^=(ba)^</em>^b  , (a|b)^<em>^=(a^</em>^b^<em>^)^</em>^</p>
</li>
<li><p>常用的正规式</p>
<img src="https://s2.loli.net/2022/06/14/4bjIEawFm3APiQG.png" alt="image-20220612141509718" style="zoom:80%;" /></li>
<li><p>正规式运算规则</p>
<p>连接不满足交换律.</p>
<img src="https://s2.loli.net/2022/06/14/keN8bymAXfIVUiL.png" alt="image-20220612141624199" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>关于自上而下的分析方法存在的问题</strong><ul>
<li>可能存在的左递归导致的无线循环</li>
<li>分析过程成,多个候选式导致的回溯,产生一定的开销</li>
<li>虚假匹配问题</li>
<li>使用自上而下的语法分析无法确定具体的出错位置</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  属性文法的杂碎知识</p>
<ul>
<li><p>语义规则</p>
<p>语义规则的形式为$b=f(c_1,c_2,\cdots,c_k)$ </p>
</li>
<li><p>综合属性</p>
<p>综合属性来源于产生式右边的文法符号的属性</p>
<blockquote>
<p>终结符只有综合属性,由词法分析器来提供</p>
<p><strong>只使用综合属性的文法称为S-属性文法.</strong></p>
<p>通常通过自底向上的方法计算综合属性值.</p>
</blockquote>
</li>
<li><p>继承属性</p>
<p>继承属性是指产生式右边的文法符号的某个属性,是取决于其兄弟节点后者产生式左侧的非终结符的属性</p>
<blockquote>
<p>文法开始符号的所有继承属性作为属性计算前的初始值</p>
</blockquote>
</li>
<li><p><strong>语法制导翻译</strong>(软院往年考过!)</p>
<blockquote>
<p><strong>由源程序的语法结构所驱动的处理方法,称为语法制导翻译.</strong></p>
<p>其语义规则计算可能会产生代码\在符号表中存放信息\给出错误信息\执行<strong>任何其他动作</strong>.</p>
</blockquote>
<blockquote>
<p>为文法的每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则，完成有关语义分析和代码生成的工作。</p>
<p>➢ 在<strong>自上而下</strong>的分析中，当一个产生式<strong>匹配输入串成功时执行</strong>；</p>
<p>➢ 在<strong>自下而上</strong>的分析中，当一个<strong>产生式被用于归约时执行</strong>。</p>
</blockquote>
</li>
<li><p>依赖图</p>
<p>如果一个节点的属性b依赖于属性c,则从c绘制向b的有向边.</p>
<p>注意,这里的节点不是文法符号,而是每个文法符号的每个属性.</p>
</li>
<li><p>一遍扫描的处理方法</p>
</li>
<li><p>S-属性文法（只使用综合属性）</p>
<p>其属性的计算遵循从下到上的计算方法，通常借助<strong>LR分析器</strong>实现。表现为在LR分析器的【状态栈 | 符号栈】的符号栈中添加符号的属性值。</p>
</li>
<li><p>L-属性文法</p>
<blockquote>
<p>概念：如果对于每个产生式𝐴 → 𝑋1𝑋2 … 𝑋𝑛，其语义规则中的每个属性或者是综合属性，或者是𝑋𝑖(1 ≤ 𝑖 ≤ 𝑛)的一个继承属性且这个继承属性仅依赖于：</p>
<p>➢ 产生式右部𝑋𝑖 的<strong>左边符号</strong>𝑋1, 𝑋2, … , 𝑋𝑖−1的属性； </p>
<p>➢ 产生式左部𝐴的继承属性。 </p>
</blockquote>
<p>S属性文法一定是L属性文法。可以采用自上而下的翻译，也可以采用自下而上的翻译。</p>
</li>
<li><p>翻译模式的设计：</p>
<ul>
<li><p>自上而下</p>
<p>对于既有综合属性又有继承属性的情况：</p>
<p>① 产生式右部符号的继承属性，必须在这个符号以前的动作中计算出来；</p>
<p>② 一个动作不能引用这个动作右边符号的综合属性； </p>
<p>③ 产生式左部的𝑉𝑁的综合属性，只有在它所引用的所有属性都计算出来以后才能计算（放到右边末尾）。</p>
</li>
<li><p>自下而上</p>
<p>要求语义动作放在产生式末尾</p>
<p>解决方案：引入空符号产生式（只需要处理动作，不需要处理属性计算）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可能会考到"><a href="#可能会考到" class="headerlink" title="可能会考到"></a><strong>可能会考到</strong></h2><ul>
<li><p><input disabled="" type="checkbox">  对于<strong>上下文无关文法的定义</strong>和一些约定</p>
<p>具体概念表示为:<strong>它所定义的文法范畴（或语法单位）是完全独立于这种范畴可能出现的环境的。</strong></p>
<p>通过一个四元式进行定义:<br>$$<br>G=(V_T,V_N,S,P)<br>$$<br>其中从前到后的意义分别是:</p>
<p>终结符号\非终结符号\开始符号\ <strong>产生式集合</strong></p>
<p>其中产生式集合中元素的形式如下:<br>$$<br>P\rarr \alpha<br>$$<br>其中的P是属于非终结符号,\alpha属于<strong>非终结符号与终结符号的闭包.</strong></p>
<p><strong>一些约定内容:</strong></p>
<p>使用<strong>大写字母</strong>代表非终结符</p>
<p>使用<strong>小写字母</strong>代表终结符</p>
<p>使用<strong>希腊字母</strong>代表终结符和非终结符组成的字符串.</p>
<p><strong>对于语言的描述</strong>: 使用一种形式将文法G所产生的句子的全体是一个语言,表示为<strong>集合的形式</strong><br>$$<br>L(G)={a|S<br>\stackrel{+}{\Rarr}<br>\alpha }<br>$$<br>或者也可以使用描述的方式进行书写.</p>
</li>
</ul>
<ul>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  正规式到正规文法的改写规则以及正规文法的概念</p>
<ul>
<li><p>正规式的递归定义</p>
<img src="https://s2.loli.net/2022/06/14/SrRUMTVdJKWEXnc.png" alt="image-20220612152430625" style="zoom:80%;" /></li>
<li></li>
</ul>
<img src="https://s2.loli.net/2022/06/14/1TFi89LaJdQwSVu.png" alt="image-20220612142039208" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/06/14/BgwJ8lN36oPzxWO.png" alt="image-20220612142210536" style="zoom:50%;" /></li>
<li><p><input disabled="" type="checkbox">  翻译句子相关的知识点</p>
<ul>
<li><p>后缀式</p>
</li>
<li><p>三地址代码(例如X=A+B) 四元式</p>
</li>
<li><p>说明语句的翻译  例如<code>int a,b;</code> 应该得到的名字表中应存储<code>a,b:int</code> (符号表的填写)</p>
<img src="https://s2.loli.net/2022/06/15/7LpoxVv9K4XyFDl.png" style="zoom:80%;" /></li>
<li><p>int与real的转换? 课后题</p>
</li>
<li><p>布尔表达式和控制条件?</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> 运行时空间组织PPT</li>
</ul>
<h2 id="必考知识点"><a href="#必考知识点" class="headerlink" title="必考知识点"></a>必考知识点</h2><ul>
<li><p><strong>画图表示编译过程的各阶段</strong></p>
<img src="https://s2.loli.net/2022/06/14/F5u84fbTcx62qQa.png" alt="image-20220610232132366" style="zoom:67%;" />

<p>或许有可能要我们<strong>解释这个图的具体含义?</strong></p>
<ul>
<li><p><strong>词法分析器:</strong></p>
<p>又称<strong>扫描器</strong>,输入源程序,从左到右逐个字符地对源程序扫描,进行词法分析,输出单词符号.</p>
</li>
<li><p><strong>语法分析器:</strong></p>
<p>又称分析器，对单词符号串进行语法分析，识别出各类语法单位，最终判断输入串是否构成语法上正确的“程序”。</p>
</li>
<li><p><strong>语义分析和中间代码生成器:</strong></p>
<p>按照语义规则对语法分析器归约（或推导）出的语法单位进行语义分析，并把它们翻译成一定形式的<strong>中间代码</strong>。</p>
</li>
<li><p><strong>优化器:</strong></p>
<p>对中间代码进行优化处理</p>
</li>
<li><p><strong>目标代码生成器:</strong></p>
<p>把中间代码翻译成目标代码。</p>
</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox">  二义文法</p>
<ul>
<li><p>概念</p>
<p>如果一个文法的某个句子对应两棵不同的语法树，<strong>即其最左（最右）推导不唯一</strong>，称该文法为二义文法。</p>
</li>
<li><p>文法的二义性与语言的二义性是不同的概念.</p>
<p>具体而言:</p>
<ul>
<li>可能存在两个不同的文法G和G’,其中一个是二义的,一个是无二义的,但是有L(G)=L(G’);</li>
<li>对于一个语言,我们常常希望其文法是无二义的,因为我们希望对它每个语句的分析是唯一的；</li>
</ul>
</li>
<li><p>考点</p>
<p>证明某个文法是二义的,具体需要自己找出一个例子,推导出两棵不同的语法树.</p>
</li>
<li><p>求解</p>
<p><strong>(优先级越高越远离开始符号)</strong></p>
</li>
<li><p>例题</p>
<p>𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝑖，构造该文法的无二义文法，使它们表示的语言相同，并给出句子 i*i+i的最右推导。</p>
<img src="https://s2.loli.net/2022/06/14/nX2BCMYvtqpT3Em.png" alt="image-20220611235922378" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  短语和句柄</p>
<ul>
<li><p>短语定义:</p>
<p>对文法𝐺[𝑆]，如果有$𝑆\stackrel{*}{\Rarr}𝛼𝐴𝛿$ 且 $𝐴 \stackrel{+}{\Rarr}𝛽$ ，则称𝛽是句型𝛼𝛽𝛿相对于非终结符号𝐴的短语。</p>
</li>
<li><p>直接短语</p>
<p>如果有$A\Rarr\beta$,称𝛽是句型𝛼𝛽𝛿相对于𝐴的<strong>直接短语</strong></p>
<p>通常对于直接短语的判断方式是通过对给定的句型,依照文法绘制对应的语法树。如果想要判断短语$\alpha$是不是直接短语，就看其父节点$A$的所有<strong>孩子节点</strong>（包含$\alpha$ 在内），是否都是<strong>叶子节点</strong>，如果是，则这里的叶子节点们组成的短语就是直接短语。</p>
</li>
<li><p>句柄</p>
<p>一个句型的<strong>最左直接短语</strong>称为该句型的句柄</p>
</li>
</ul>
</li>
<li><p><strong>FA写正规式</strong></p>
<p>根据自动机合并为正规式的方式,实际上是对正规式转化为非确定有限自动机的逆过程.</p>
<img src="https://s2.loli.net/2022/06/14/ObU3QqcZwIEmRur.png" alt="image-20220612185846837" style="zoom:67%;" /></li>
<li><p><input checked="" disabled="" type="checkbox">  消除左递归</p>
<p><strong>常见的</strong>/根本的措施就是通过添加非终结符:<br>$$<br>P \rarr P\alpha | \beta \<br>\Darr \<br>P \Rarr \beta \alpha ^*\<br>\Darr \<br>P\rarr \beta P’ \<br>P’ \rarr \alpha P’ | \epsilon<br>$$<br>利用正规式作为媒介,转换为右递归文法.</p>
<p>同样的道理,可以将上述内容进行推广.<br>$$<br>P\rarr P\alpha_1 | P\alpha_2|\cdots | P\alpha_n |\beta_1 | \beta_2 | \cdots|\beta_m \<br>\Darr\<br>P\rarr P(\alpha_1 | \alpha_2| \cdots| \alpha_n)|(\beta_1 | \beta_2| \cdots|\beta_m) \<br>\Darr \<br>P\rarr (\beta_1 | \beta_2| \cdots|\beta_m) P’ \<br>P’\rarr (\alpha_1 | \alpha_2| \cdots| \alpha_n)P’|\epsilon<br>$$</p>
<p>除了上述显示的左递归之外,还存在着隐式的左递归,对应于如果从A1推导到A2,那么绘制其对应的图中,节点A1和A2之间存在着一条有向边.</p>
<p>消除隐含左递归的方法就是:</p>
<pre><code>1. 给定一个非终结符号的排序,例如A1,A2 ... 
2. 保证每个推导公式中右侧的A_i的对应位置在左侧A_j的右侧.也就是必须从排序较小着推导到排序较大者.
3. 对满足第2条的,且包含了左递归的进行左递归消除.
</code></pre>
<p>如果想要使产生的产生式最少,那么:</p>
<blockquote>
<p>如果从开始符号获取到的值依次是A1,A2,…An,</p>
<p>那么排序时最好是按照这个顺序的逆序进行排列,即An,…,A2,A1</p>
<p><strong>????</strong></p>
</blockquote>
</li>
<li><p><input checked="" disabled="" type="checkbox">  提取公因子</p>
<p>目的就是消除回溯.</p>
<p>这里我们使用的提取左公因子的方法如下:<br>$$<br>P \rarr \alpha A_1 | \alpha A_2 | \cdots | \alpha A_n | \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr \<br>P\rarr \alpha (A_1 | A_2 |\cdots| A_n )| \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr\<br>P\rarr \alpha A | \beta_1 | \beta_2 |\dots|\beta_m \ ,\<br>A\rarr A_1 | A_2 |\cdots| A_n<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  后缀表达式</p>
</li>
<li><p><input disabled="" type="checkbox">  符号表</p>
</li>
<li><p><input disabled="" type="checkbox">  运行时空间组织</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  静态链和动态链</p>
<p>这里主要是关于静态链内容的确定方式:</p>
<p>静态链内容填写分为三种情况:</p>
<ul>
<li><p>第N层调用第N+1层,也就相当于父亲节点调用孩子节点</p>
<p>第N+1层的静态链填写调用过程 ( 第 N层过程 ) 的最新活动记录的起始地址 .也就相当于被调用者的静态链=<strong>调用者的SP</strong></p>
</li>
<li><p>第N层调用第N层,相当于兄弟节点调用其对应的兄弟节点</p>
<p>被调用者的静态链内容填写为 调用过程 ( 第 N层过程 ) 的静态链的值。也就是被调用者静态链=<strong>调用者的静态链.</strong></p>
</li>
<li><p>第N层调用第N-X层</p>
<p>相当于第某一个后代节点调用其祖先节点.</p>
<p>被调用者的静态链填写需要<strong>沿着调用者的静态链跳转X次</strong>到达的活动记录的静态链内容,即被调用者的静态链内容.</p>
</li>
</ul>
</li>
</ul>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul>
<li><p><strong>词法分析,给定正规式</strong></p>
<blockquote>
<p>构造NFA<br>确定化<br>最小化</p>
</blockquote>
<h2 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h2><ul>
<li><p>经常用到的表现形式: <strong>状态转换图</strong></p>
<ul>
<li><p>使用<strong>结点表示状态</strong>,用<strong>圆圈</strong>表示</p>
</li>
<li><p>状态之间使用箭弧链接,上面的数字代表射出节点状态下可能出现的状态.</p>
</li>
<li><p>一张转换图只包含有限个状态,<strong>必然有一个为初态</strong>,<strong>至少有一个终态</strong>.</p>
</li>
<li><p><strong>初态要添加箭头</strong>指向表示,<strong>终态使用双圆圈</strong>表示.</p>
</li>
<li><p>注意到,如果判定时需要添加一个额外的符号来表示转换到终结态,那终结态应该还要退还这个多输入的额外的符号给输入串.使用<strong>终态节点上打星号</strong>代表多读入了一个不属于标识符的字符.</p>
<img src="https://s2.loli.net/2022/06/14/9ZLupBGYzcJRC6i.png" alt="image-20220612133236416" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><ul>
<li><p>什么是DFA</p>
<p>一个确定有限自动机使用五元式来表示 $M=(S,\Sigma,\delta,s_0,F)$</p>
<p>其中各个内容的含义:</p>
<ul>
<li><p>S: 一个有限集,每个元素代表一个状态</p>
</li>
<li><p>$\Sigma$: 有穷字母表,每个元素代表一个输入字符</p>
</li>
<li><p>$\delta$: 是从$S \times \Sigma$到$S$的单值映射,$\delta (s,a)=s’$代表当 当前状态为s,输入为a时,将转换到下一个状态s’, s’又被称为后继状态.</p>
</li>
<li><p>$s_0 \in S$, 代表<strong>唯一的初态</strong>.(<strong>确定有限自动机初态唯一</strong>)</p>
</li>
<li><p>$F\subseteq S$,是一个终态集,(<strong>可以为空集</strong>)</p>
</li>
</ul>
<p>综合来说,就是(状态集,输入集,转换关系,初态,终态集)</p>
</li>
<li><p>一个DFA可以表示为一张状态转换图(最左侧列代表状态),最上面行代表输入.</p>
<p>若M的初态结点同时又是终态结点，则空字𝜀可为M所识别（或接受）</p>
</li>
<li><p><strong>DFA的构造问题:给定一个正规式,将其转化DFA</strong></p>
</li>
<li><p>优缺点:</p>
<p>编程实现容易,效率高,但是构造困难</p>
</li>
</ul>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><ul>
<li><p>关于非确定有限自动机NFA</p>
<p>基本同上,同样使用五元式进行表示,不过不同的是:</p>
<ul>
<li><p>原本的$\delta$代表的单值映射,这里是$S \times \Sigma^* 到S$的<strong>子集</strong>的映射.也就是<br>$$<br>\delta:S \times \Sigma^{*} \rarr 2^{S}<br>$$</p>
</li>
<li><p>原本的初态是唯一的,这里的初态是<strong>非空初态集</strong></p>
</li>
<li><p>另外,在这里的弧上可以出现空字**$\epsilon$**</p>
</li>
</ul>
</li>
<li><p><strong>从一个正规式转化为NFA</strong></p>
</li>
<li><p><strong>给定一个NFA,如何将其转化为正规式</strong></p>
</li>
<li><p>优缺点</p>
<p>NFA构造比较容易,但是编程实现有回溯</p>
</li>
</ul>
<h2 id="NFA的确定化-转变为DFA"><a href="#NFA的确定化-转变为DFA" class="headerlink" title="NFA的确定化(转变为DFA)"></a>NFA的确定化(转变为DFA)</h2><ul>
<li><p>使得初态和终态唯一(引入新的初态X和终态Y).</p>
<p>从𝑋 到𝑆0 的任意状态结点连一条𝜀箭弧；</p>
<p>从𝐹中的任意状态结点连一条𝜀箭弧到𝑌。</p>
</li>
<li><p>分裂</p>
<p>使得每条箭弧上或为$\epsilon$ ,或者是$\Sigma$中的单个字符</p>
<img src="https://s2.loli.net/2022/06/14/azZdQeVgf3Kbnos.png" alt="image-20220612160632690" style="zoom:67%;" /></li>
<li><p>寻找可合并状态</p>
<p>引入闭包的概念,定义I的ε闭包ε_Closure(I)为：</p>
<p>➢ 若𝑞 ∈ 𝐼，则𝑞 ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)； </p>
<p>➢ 若𝑞 ∈ 𝐼, 𝛿(𝑞, 𝜀) = 𝑞′，则𝑞′ ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)。(也即是从闭包内的状态接受空字可以转移到的状态)</p>
<p><strong>具体过程步骤:</strong></p>
<img src="https://s2.loli.net/2022/06/14/YwEpAqB8FsrJCRW.png" alt="image-20220612161011278" style="zoom:67%;" /></li>
<li><p>状态合并</p>
<p>➢ 每个状态子集视为新的状态； </p>
<p>➢ <strong>初态为首行首列；</strong> (而不是含有初态的就是初态!)</p>
<p>➢ <strong>终态是含有原终态的状态子集。</strong></p>
</li>
</ul>
<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2><ul>
<li><p>定义等价状态</p>
<ul>
<li><p>如果从𝑠出发能读出某个字𝑤而停在终态，那么从𝑡出发也能读出字𝑤停在终态；</p>
</li>
<li><p>如果从𝑡出发能读出某个字𝑤而停在终态，那么从𝑠出发也能读出字𝑤停在终态。</p>
</li>
</ul>
</li>
<li><p>可区别状态</p>
<ul>
<li>终态和非终态 可区别的</li>
<li>射出弧不同(一个有a,一个没有a) 可区别的</li>
<li>通过同样的输入得到的输出是可区别的  可区别的</li>
<li>通过某个输入到达的状态及其等价状态,对另一个来说使用某个输入是不可到达的  可区别的</li>
</ul>
</li>
<li><p>化简时,首先从<strong>终态与非终态的区分</strong>开始</p>
<p>每次都要检查原本同一个集合中的元素得到相同的输入后的输出是否在同一个集合中.如果不,将两者剥离.</p>
</li>
<li><p>化简后的弧的创建:</p>
<img src="https://s2.loli.net/2022/06/14/e9wCyIgutAvmrJY.png" alt="image-20220612171255023" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><ul>
<li><p><strong>LL(1)分析,给出文法</strong></p>
<blockquote>
<p>构造First集合<br>否则Follow集合<br>构造LL(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>LL(1)文法中<strong>最重要的两个概念</strong>:</p>
<ul>
<li>终结首符集 (头符号集)</li>
<li>后继终结符号集(后继符号集)产生原因在于对空字进行匹配时,需要依据这里的判断来决定是否要进行匹配.</li>
</ul>
<p>进行LL(1)分析时,需要满足的条件如下,满足以下条件,才称之为LL(1)文法:</p>
<blockquote>
<p>L: From <code>L</code>eft to Right</p>
<p>L: 最左推导</p>
<p>1: 分析一步,看右侧的一个符号</p>
</blockquote>
<ul>
<li>文法不含左递归；  –<code>不含有左递归</code></li>
<li>对𝐴 → 𝛼1| … |𝛼𝑛的每对候选式，有𝐹𝑖𝑟𝑠𝑡 (𝛼𝑖) ∩ 𝐹𝑖𝑟𝑠𝑡(𝛼𝑗) = ∅，其中𝑖 ≠ 𝑗；  <code>同一个推导式的右侧首符集无公用元素</code></li>
<li>对非终结符号𝐴，若𝜀 ∈ 𝐹𝑖𝑟𝑠𝑡(𝐴)，有𝐹𝑖𝑟𝑠𝑡 (𝐴) ∩ 𝐹𝑜𝑙𝑙𝑜𝑤 (𝐴) = ∅。 <code>同一个非终结符的首符集与后继符号集不相交</code></li>
</ul>
<p>分析时:</p>
<img src="https://s2.loli.net/2022/06/14/5M6sg8SJtnvGRap.png" alt="image-20220614093624431" style="zoom:67%;" />



<p><strong>First集合的求解:</strong></p>
<img src="https://s2.loli.net/2022/06/14/GE6m7nKSahcukLA.png" alt="image-20220614093824988" style="zoom:80%;" />

<p>向首符集中添加空字\epsilon的条件: </p>
<ul>
<li>明确说明了从X能直接推导 epsilon</li>
<li>对于X推导出的某一串连续的非终结符,这一串非终结符都含有空字epsilon</li>
</ul>
<p>对于<strong>Follow集合</strong>:</p>
<ul>
<li><p>特别地一个终结符<code>#</code>,在S所在的推导式的右侧添加<code>#</code>,进而为对应的非终结符提供Follow集合中的<code>#</code></p>
</li>
<li><p>具体求解</p>
<img src="https://s2.loli.net/2022/06/14/jEIOKosknHblWA1.png" alt="image-20220614094603428" style="zoom:80%;" /></li>
</ul>
<p><strong>构造LL(1)分析表</strong></p>
<img src="https://s2.loli.net/2022/06/14/cOg9BvlFPeHo2S4.png" alt="image-20220614095418380" style="zoom:80%;" />

<p>表格的格式如下所示:</p>
<table>
<thead>
<tr>
<th></th>
<th>$V_{T1}$</th>
<th>$V_{T2}$</th>
<th>$\cdots$</th>
<th>#</th>
</tr>
</thead>
<tbody><tr>
<td>$V_{N1}$</td>
<td></td>
<td></td>
<td></td>
<td><strong>千万不要忘记!</strong></td>
</tr>
<tr>
<td>$V_{N2}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$V_{N3}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>分析过程</strong></p>
<img src="https://s2.loli.net/2022/06/14/2T7zDNJRMOHaklq.png" alt="image-20220614095609097" style="zoom: 80%;" />

<p>进行分析时的表格格式如下所示:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>文法符号栈</th>
<th>输入串</th>
<th>所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h3><ul>
<li><p><strong>LR分析,给出文法</strong></p>
<blockquote>
<p>构造拓广文法<br>构造拓广文法的LR(0)/LR(1)项目集规范族<br>构造LR(0)/LR(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>分析法的优点:</p>
<ul>
<li>多数上下文无关文法描述的语言都可以使用LR分析器识别.</li>
<li>LR能分析的文法包括LL(1)能分析的文法.</li>
<li>扫描输入串时可以发现任何错误,并能准确指出出错地点.</li>
</ul>
<p>常见的LR分析四种方法包括:</p>
<ul>
<li>LR(0)分析法,局限性大</li>
<li>简单LR(SLR)</li>
<li>规范LR</li>
<li>向前LR(LALR)</li>
</ul>
<h3 id="定义LR文法以及相关概念"><a href="#定义LR文法以及相关概念" class="headerlink" title="定义LR文法以及相关概念"></a>定义LR文法以及相关概念</h3><ul>
<li><p>LR文法:文法能够构造一个LR分析表,使得其每一个入口都唯一</p>
</li>
<li><p>规范句型: 包含句柄的可规约句型</p>
</li>
</ul>
<h3 id="LR（0）分析法"><a href="#LR（0）分析法" class="headerlink" title="LR（0）分析法"></a>LR（0）分析法</h3><p>需要注意一点: $A\rarr \epsilon$只有一个状态$A\rarr \dot{}$</p>
<p>分析过程:</p>
<ol>
<li><p>首先构造拓广文法</p>
<p>也就是$G_1=(V_T,V_N,S,P)$构造为$G_2=(V_T,V_N ∪{S’},S’,P∪{S’ \rarr S})$</p>
<p>我们称G2是G1的拓广文法.</p>
</li>
<li><p>构造拓广文法的LR(0)项目集规范族</p>
<p>这里需要使用到闭包的相关概念.</p>
</li>
<li><p>构造分析表</p>
</li>
<li><p>识别句子</p>
</li>
</ol>
<p>认为SLR与LR(1)的主要区别在于:</p>
<p>SLR避免冲突的方式,是对整个文法中每个非终结符求取其对应的FOLLOW集合内容,从而得到对应的后继终结符,根据决定规约/移进时,对应规约式规约后的非终结符的FOLLOW集合中是否含有下一个要移入的终结符来判断是否选择规约.</p>
<p>而LR(1)的方法相较于SLR更加细化,也就是其根据的不是宽泛的整个语法中的FOLLOW集合,而是单纯根据对应推导式的FOLLOW集合,具体是指对应<code>·</code>所在的位置后面,看作一个整体,看其整体的FIRST集合.</p>
<p>三者的差别反映在分析表的构造上:</p>
<ul>
<li><p>对于LR(0),如果<code>·</code>到达了式子的末尾,那么对应在分析表的所有终结符对应位置都要填写规约式.</p>
</li>
<li><p>对于SLR,只在规约后的非终结符的FOLLOW对应的终结符的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/SOoJrq8fWihBDCK.png" alt="image-20220614223033464"></p>
</li>
<li><p>对于LR(1),在对应<code>·</code>在式子末尾时,式子的<code>前瞻符号</code>的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/QAOpidHvRF6oqnD.png" alt="image-20220614223001637"></p>
</li>
</ul>
</li>
</ul>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><ul>
<li><p><strong>给出翻译模式和高级语言程序，翻译句子</strong></p>
<blockquote>
<p>一般涉及多种类型句子的综合，也可能涉及声明语句填写符号表。</p>
</blockquote>
</li>
</ul>
<h3 id="DAG优化"><a href="#DAG优化" class="headerlink" title="DAG优化"></a>DAG优化</h3><ul>
<li><p><strong>给出基本代码块</strong></p>
<blockquote>
<p><strong>对于给定的基本块构造DAG</strong></p>
<p><strong>按照构造DAG的节点顺序重新写中间代码</strong></p>
<p><strong>利用节点排序算法对节点排序,并根据排序后的节点顺序写中间代码</strong></p>
<p><strong>对上一步的中间代码利用简单代码生成算法生成目标代码</strong></p>
<blockquote>
<p>写出优化后的中间代码<br>写出DAG目标优化后的中间代码<br>根据变量活跃性和寄存器信息，写出目标代码</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul>
<li><p>构造语言</p>
<p>给出语言$L(G)={a^{m}b^{n}|1&lt;=n&lt;=m&lt;=2n}$,  请构造对应文法.</p>
<p>答:<br>$$<br>G(S):\<br>S=ab | aab\<br>S=aSb | aaSb<br>$$</p>
</li>
<li><p>作业题</p>
<img src="https://s2.loli.net/2022/06/14/oYXO7H5rIswWVJm.png" alt="image-20220612004824158" style="zoom:67%;" /></li>
</ul>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3>
    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <p><h4>© 2021 Baxkiller Powered By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="db91ONAaJE7csgIBIIeWxEXK-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="V4ivekKhnC8pvzwTKL40Pnx8">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
