<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/ico.ico >
    <title>
        Blog | Baxkiller
    </title>
    <meta name="description" content= Hey Bro! Here's Baxkiller's Blog Site. >
    <meta name="keywords" content= Blog,Hexo,Theme,Baxkiller,Coder >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Compile_Principle_Review
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="概念题-不考"><a href="#概念题-不考" class="headerlink" title="概念题(不考"></a>概念题(不考</h2><ul>
<li><p><input disabled="" type="checkbox">  什么是编译程序</p>
<p>翻译程序:</p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  表达式得形成规则</p>
<p>➢ 变量（包括下标变量）、常数是<strong>表达式</strong>；</p>
<p>➢ 若E1、E2为表达式，θ是一个二元算符，则$E_1\ θ\ E_2$是一个表达式；</p>
<p>➢ 若E是表达式，θ为一元算符，则$θE（或Eθ）$是表达式；</p>
<p>➢ 若E是表达式，则(E)是表达式。</p>
</li>
<li><p><input disabled="" type="checkbox">  运算顺序和结合性(关于<strong>运算符优先级</strong>的知识)</p>
</li>
<li><p><strong>闭包</strong></p>
<p>某个符号串的闭包运算规则是,但是经过的是有限次的链接而成的,也就是闭包中的每个字符串的长度有限.<br>$$<br>V^{<em>}=V^{0} \or V^{1} \or V^{2} \or V^{3} \or \cdots<br>$$<br><strong>正则闭包</strong><br>$$<br>V^{+}=VV^{</em>}<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  关于空集与空字的区分!</p>
<p>空集,即$\varnothing$,代表的是${}$,是集合</p>
<p>空字,用$\epsilon$表示,代表的是不含有任何符号的序列,是一个集合中的元素</p>
<p>而${\epsilon}$往往用来代表某个符号串的0次连接积,也就是$V^{0}$</p>
</li>
</ul>
<ul>
<li><p><strong>关于推导</strong></p>
<p>最右推导: 推导过程中,总是最先替换最右的非终结符,称之为<strong>最右推导</strong></p>
<p>最右规约:规约时,总是最先规约最右的非终结符,称之为最右规约.</p>
<p><strong>规范推导(最右推导)</strong></p>
<p><strong>规范规约(最左规约)</strong></p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  知道常见的状态转换图</p>
</li>
<li><p><input disabled="" type="checkbox">  正规式之间的运算规则以及常见的等价正规式</p>
<ul>
<li><p>等价的正规式    </p>
<p>例如比较常见的是b(a|b)^<em>^=(ba)^</em>^b  , (a|b)^<em>^=(a^</em>^b^<em>^)^</em>^</p>
</li>
<li><p>常用的正规式</p>
<img src="https://s2.loli.net/2022/06/14/4bjIEawFm3APiQG.png" alt="image-20220612141509718" style="zoom:80%;" /></li>
<li><p>正规式运算规则</p>
<p>连接不满足交换律.</p>
<img src="https://s2.loli.net/2022/06/14/keN8bymAXfIVUiL.png" alt="image-20220612141624199" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>关于自上而下的分析方法存在的问题</strong><ul>
<li>可能存在的左递归导致的无线循环</li>
<li>分析过程成,多个候选式导致的回溯,产生一定的开销</li>
<li>虚假匹配问题</li>
<li>使用自上而下的语法分析无法确定具体的出错位置</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  属性文法的杂碎知识</p>
<ul>
<li><p>语义规则</p>
<p>语义规则的形式为$b=f(c_1,c_2,\cdots,c_k)$ </p>
</li>
<li><p>综合属性</p>
<p>综合属性来源于产生式右边的文法符号的属性</p>
<blockquote>
<p>终结符只有综合属性,由词法分析器来提供</p>
<p><strong>只使用综合属性的文法称为S-属性文法.</strong></p>
<p>通常通过自底向上的方法计算综合属性值.</p>
</blockquote>
</li>
<li><p>继承属性</p>
<p>继承属性是指产生式右边的文法符号的某个属性,是取决于其兄弟节点后者产生式左侧的非终结符的属性</p>
<blockquote>
<p>文法开始符号的所有继承属性作为属性计算前的初始值</p>
</blockquote>
</li>
<li><p><strong>语法制导翻译</strong>(软院往年考过!)</p>
<blockquote>
<p><strong>由源程序的语法结构所驱动的处理方法,称为语法制导翻译.</strong></p>
<p>其语义规则计算可能会产生代码\在符号表中存放信息\给出错误信息\执行<strong>任何其他动作</strong>.</p>
</blockquote>
<blockquote>
<p>为文法的每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则，完成有关语义分析和代码生成的工作。</p>
<p>➢ 在<strong>自上而下</strong>的分析中，当一个产生式<strong>匹配输入串成功时执行</strong>；</p>
<p>➢ 在<strong>自下而上</strong>的分析中，当一个<strong>产生式被用于归约时执行</strong>。</p>
</blockquote>
</li>
<li><p>依赖图</p>
<p>如果一个节点的属性b依赖于属性c,则从c绘制向b的有向边.</p>
<p>注意,这里的节点不是文法符号,而是每个文法符号的每个属性.</p>
</li>
<li><p>一遍扫描的处理方法</p>
</li>
<li><p>S-属性文法（只使用综合属性）</p>
<p>其属性的计算遵循从下到上的计算方法，通常借助<strong>LR分析器</strong>实现。表现为在LR分析器的【状态栈 | 符号栈】的符号栈中添加符号的属性值。</p>
</li>
<li><p>L-属性文法</p>
<blockquote>
<p>概念：如果对于每个产生式𝐴 → 𝑋1𝑋2 … 𝑋𝑛，其语义规则中的每个属性或者是综合属性，或者是𝑋𝑖(1 ≤ 𝑖 ≤ 𝑛)的一个继承属性且这个继承属性仅依赖于：</p>
<p>➢ 产生式右部𝑋𝑖 的<strong>左边符号</strong>𝑋1, 𝑋2, … , 𝑋𝑖−1的属性； </p>
<p>➢ 产生式左部𝐴的继承属性。 </p>
</blockquote>
<p>S属性文法一定是L属性文法。可以采用自上而下的翻译，也可以采用自下而上的翻译。</p>
</li>
<li><p>翻译模式的设计：</p>
<ul>
<li><p>自上而下</p>
<p>对于既有综合属性又有继承属性的情况：</p>
<p>① 产生式右部符号的继承属性，必须在这个符号以前的动作中计算出来；</p>
<p>② 一个动作不能引用这个动作右边符号的综合属性； </p>
<p>③ 产生式左部的𝑉𝑁的综合属性，只有在它所引用的所有属性都计算出来以后才能计算（放到右边末尾）。</p>
</li>
<li><p>自下而上</p>
<p>要求语义动作放在产生式末尾</p>
<p>解决方案：引入空符号产生式（只需要处理动作，不需要处理属性计算）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可能会考到"><a href="#可能会考到" class="headerlink" title="可能会考到"></a><strong>可能会考到</strong></h2><ul>
<li><p><input disabled="" type="checkbox">  对于<strong>上下文无关文法的定义</strong>和一些约定</p>
<p>具体概念表示为:<strong>它所定义的文法范畴（或语法单位）是完全独立于这种范畴可能出现的环境的。</strong></p>
<p>通过一个四元式进行定义:<br>$$<br>G=(V_T,V_N,S,P)<br>$$<br>其中从前到后的意义分别是:</p>
<p>终结符号\非终结符号\开始符号\ <strong>产生式集合</strong></p>
<p>其中产生式集合中元素的形式如下:<br>$$<br>P\rarr \alpha<br>$$<br>其中的P是属于非终结符号,\alpha属于<strong>非终结符号与终结符号的闭包.</strong></p>
<p><strong>一些约定内容:</strong></p>
<p>使用<strong>大写字母</strong>代表非终结符</p>
<p>使用<strong>小写字母</strong>代表终结符</p>
<p>使用<strong>希腊字母</strong>代表终结符和非终结符组成的字符串.</p>
<p><strong>对于语言的描述</strong>: 使用一种形式将文法G所产生的句子的全体是一个语言,表示为<strong>集合的形式</strong><br>$$<br>L(G)={a|S<br>\stackrel{+}{\Rarr}<br>\alpha }<br>$$<br>或者也可以使用描述的方式进行书写.</p>
</li>
</ul>
<ul>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  正规式到正规文法的改写规则以及正规文法的概念</p>
<ul>
<li><p>正规式的递归定义</p>
<img src="https://s2.loli.net/2022/06/14/SrRUMTVdJKWEXnc.png" alt="image-20220612152430625" style="zoom:80%;" /></li>
<li></li>
</ul>
<img src="https://s2.loli.net/2022/06/14/1TFi89LaJdQwSVu.png" alt="image-20220612142039208" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/06/14/BgwJ8lN36oPzxWO.png" alt="image-20220612142210536" style="zoom:50%;" /></li>
<li><p><input disabled="" type="checkbox">  翻译句子相关的知识点</p>
<ul>
<li><p>后缀式</p>
<p>运算符在后面</p>
</li>
<li><p>三地址代码(例如X=A+B) 四元式</p>
<p>种类: 二元算数运算符/逻辑算符;一元算符;赋值语句;无条件转移;条件转移;过程调用;索引赋值;地址与指针赋值;</p>
<p>四元式=$(op,arg1,arg2,result)$</p>
</li>
<li><p>说明语句的翻译  例如<code>int a,b;</code> 应该得到的名字表中应存储<code>a,b:int</code> (符号表的填写)</p>
<img src="https://s2.loli.net/2022/06/15/7LpoxVv9K4XyFDl.png" style="zoom:80%;" /></li>
<li><p>int与real的转换? 课后题</p>
<p>两者相加的课后题，主要是利用了后缀式。</p>
<ul>
<li><p>第一问，求出类型：</p>
<p>直接写就可以。</p>
</li>
<li><p>第二问，生成代码：</p>
<p>要注意的是：程序输出时，<code>int2real</code>如果被看作是单个运算符，也需要按照后缀式的形式，先输出具体的值，在输出运算符<code>int2real</code>.</p>
<img src="https://s2.loli.net/2022/06/16/imtNjFVZhQgyX5I.png" alt="image-20220616094105658" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/16/OJvDZ2Yyjsgcah4.png" alt="image-20220616094120661" style="zoom:80%;" /></li>
<li><p>课件给定的例子:</p>
<img src="https://s2.loli.net/2022/06/16/fGaz56JQEATrKeM.png" alt="image-20220616103244140" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>布尔表达式和控制条件?</p>
<p>关于布尔表达式中的运算符优先级说明:</p>
<p>优先级从高到低:<code>非</code> &gt; <code>与</code> &gt;  <code>或</code></p>
<p>关系运算符,例如<code>&lt; &gt; &lt;= ...</code> ,内部优先级相同,整体高于布尔算符,低于算数算符.</p>
<p><strong>布尔表达式的翻译模式:</strong></p>
<img src="https://s2.loli.net/2022/06/16/TEpq2mUQYDFeob8.png" alt="image-20220616105340116" style="zoom:80%;" />

<p><strong>作为条件控制的布尔表达式:</strong></p>
<p>对于真假出口对应的链表:</p>
<ul>
<li>当遇到<code>与</code>时,需要将两个非终结符的falseList合并,</li>
<li>当遇到<code>或</code>时,需要将两个非终结符的trueList合并.</li>
</ul>
<p>对于回填函数backpatch:</p>
<ul>
<li>当遇到<code>与</code>,E2可以确定E1的truelist需要回填的地址</li>
<li>当遇到<code>或</code>,E2可以确定E1的falseList需要回填的地址</li>
</ul>
<img src="https://s2.loli.net/2022/06/16/g5QFf6qPMlWeYLm.png" alt="image-20220616112005473" style="zoom:80%;" /></li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  运行时空间组织PPT</p>
</li>
</ul>
<h2 id="必考知识点"><a href="#必考知识点" class="headerlink" title="必考知识点"></a>必考知识点</h2><ul>
<li><p><strong>画图表示编译过程的各阶段</strong></p>
<img src="https://s2.loli.net/2022/06/14/F5u84fbTcx62qQa.png" alt="image-20220610232132366" style="zoom:67%;" />

<p>或许有可能要我们<strong>解释这个图的具体含义?</strong></p>
<ul>
<li><p><strong>词法分析器:</strong></p>
<p>又称<strong>扫描器</strong>,输入源程序,从左到右逐个字符地对源程序扫描,进行词法分析,输出单词符号.</p>
</li>
<li><p><strong>语法分析器:</strong></p>
<p>又称分析器，对单词符号串进行语法分析，识别出各类语法单位，最终判断输入串是否构成语法上正确的“程序”。</p>
</li>
<li><p><strong>语义分析和中间代码生成器:</strong></p>
<p>按照语义规则对语法分析器归约（或推导）出的语法单位进行语义分析，并把它们翻译成一定形式的<strong>中间代码</strong>。</p>
<blockquote>
<p>静态语义检查通常包括: 类型检查,控制流检查,一致性检查,相关名字检查,名字的作用域分析</p>
</blockquote>
</li>
<li><p><strong>优化器:</strong></p>
<p>对中间代码进行优化处理</p>
</li>
<li><p><strong>目标代码生成器:</strong></p>
<p>把中间代码翻译成目标代码。</p>
</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox">  二义文法</p>
<ul>
<li><p>概念</p>
<p>如果一个文法的某个句子对应两棵不同的语法树，<strong>即其最左（最右）推导不唯一</strong>，称该文法为二义文法。</p>
</li>
<li><p>文法的二义性与语言的二义性是不同的概念.</p>
<p>具体而言:</p>
<ul>
<li>可能存在两个不同的文法G和G’,其中一个是二义的,一个是无二义的,但是有L(G)=L(G’);</li>
<li>对于一个语言,我们常常希望其文法是无二义的,因为我们希望对它每个语句的分析是唯一的；</li>
</ul>
</li>
<li><p>考点</p>
<p>证明某个文法是二义的,具体需要自己找出一个例子,推导出两棵不同的语法树.</p>
</li>
<li><p>求解</p>
<p><strong>(优先级越高越远离开始符号)</strong></p>
</li>
<li><p>例题</p>
<p>𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝑖，构造该文法的无二义文法，使它们表示的语言相同，并给出句子 i*i+i的最右推导。</p>
<img src="https://s2.loli.net/2022/06/14/nX2BCMYvtqpT3Em.png" alt="image-20220611235922378" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  短语和句柄</p>
<ul>
<li><p>短语定义:</p>
<p>对文法𝐺[𝑆]，如果有$𝑆\stackrel{*}{\Rarr}𝛼𝐴𝛿$ 且 $𝐴 \stackrel{+}{\Rarr}𝛽$ ，则称𝛽是句型𝛼𝛽𝛿相对于非终结符号𝐴的短语。</p>
</li>
<li><p>直接短语</p>
<p>如果有$A\Rarr\beta$,称𝛽是句型𝛼𝛽𝛿相对于𝐴的<strong>直接短语</strong></p>
<p>通常对于直接短语的判断方式是通过对给定的句型,依照文法绘制对应的语法树。如果想要判断短语$\alpha$是不是直接短语，就看其父节点$A$的所有<strong>孩子节点</strong>（包含$\alpha$ 在内），是否都是<strong>叶子节点</strong>，如果是，则这里的叶子节点们组成的短语就是直接短语。</p>
</li>
<li><p>句柄</p>
<p>一个句型的<strong>最左直接短语</strong>称为该句型的句柄</p>
</li>
</ul>
</li>
<li><p><strong>FA写正规式</strong></p>
<p>根据自动机合并为正规式的方式,实际上是对正规式转化为非确定有限自动机的逆过程.</p>
<img src="https://s2.loli.net/2022/06/14/ObU3QqcZwIEmRur.png" alt="image-20220612185846837" style="zoom:67%;" /></li>
<li><p><input checked="" disabled="" type="checkbox">  消除左递归</p>
<p><strong>常见的</strong>/根本的措施就是通过添加非终结符:<br>$$<br>P \rarr P\alpha | \beta \<br>\Darr \<br>P \Rarr \beta \alpha ^*\<br>\Darr \<br>P\rarr \beta P’ \<br>P’ \rarr \alpha P’ | \epsilon<br>$$<br>利用正规式作为媒介,转换为右递归文法.</p>
<p>同样的道理,可以将上述内容进行推广.<br>$$<br>P\rarr P\alpha_1 | P\alpha_2|\cdots | P\alpha_n |\beta_1 | \beta_2 | \cdots|\beta_m \<br>\Darr\<br>P\rarr P(\alpha_1 | \alpha_2| \cdots| \alpha_n)|(\beta_1 | \beta_2| \cdots|\beta_m) \<br>\Darr \<br>P\rarr (\beta_1 | \beta_2| \cdots|\beta_m) P’ \<br>P’\rarr (\alpha_1 | \alpha_2| \cdots| \alpha_n)P’|\epsilon<br>$$</p>
</li>
</ul>
<p>  除了上述显示的左递归之外,还存在着隐式的左递归,对应于如果从A1推导到A2,那么绘制其对应的图中,节点A1和A2之间存在着一条有向边.</p>
<p>  消除隐含左递归的方法就是:</p>
<pre><code>  1. 给定一个非终结符号的排序,例如A1,A2 ... 
  2. 保证每个推导公式中右侧的A_i的对应位置在左侧A_j的右侧.也就是必须从排序较小着推导到排序较大者.
  3. 对满足第2条的,且包含了左递归的进行左递归消除.
</code></pre>
<p>  如果想要使产生的产生式最少,那么:</p>
<blockquote>
<p>如果从开始符号获取到的值依次是A1,A2,…An,</p>
<p>那么排序时最好是按照这个顺序的逆序进行排列,即An,…,A2,A1</p>
<p><strong>????</strong></p>
</blockquote>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  提取公因子</p>
<p>目的就是消除回溯.</p>
<p>这里我们使用的提取左公因子的方法如下:<br>$$<br>P \rarr \alpha A_1 | \alpha A_2 | \cdots | \alpha A_n | \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr \<br>P\rarr \alpha (A_1 | A_2 |\cdots| A_n )| \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr\<br>P\rarr \alpha A | \beta_1 | \beta_2 |\dots|\beta_m \ ,\<br>A\rarr A_1 | A_2 |\cdots| A_n<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  后缀表达式</p>
<p>后缀表达式就是逆波兰表示法.这种方法采用的是:将运算量写在前面,将算符写在后面.满足三种:<br>$$<br><a>=a \<br>&lt;\theta e&gt;=<e>\theta \<br>&lt;E_1 \theta E_2&gt; = <E_1><E_2>\theta \<br>&lt;(E)&gt;=<E> \<br>$$<br><strong>后缀式存在的优点:</strong></p>
<p><strong>➢ 无括号，形式简洁；</strong> </p>
<p><strong>➢ 运算符的顺序与运算次序完全相同。</strong></p>
<p>对应语义规则:</p>
<img src="https://s2.loli.net/2022/06/17/IWVFYmuCh18Rokz.png" alt="image-20220616001950225" style="zoom:80%;" /></li>
<li><p><input disabled="" type="checkbox">  符号表</p>
<ul>
<li><p>符号表起到的作用?</p>
<ul>
<li>收集符号属性</li>
<li>上下文语义的合法性检查</li>
<li>目标代码生成阶段地址分配的依据</li>
</ul>
</li>
<li><p>三种组织方式</p>
<ul>
<li><p>构造多个符号表,将具有相同属性的种类的符号组织在一起</p>
<blockquote>
<p>优点: 每个符号表中存放符号的属性个数和结构完全相同</p>
<p>缺点: 一遍编译程序要同时管理若干个符号表</p>
</blockquote>
</li>
<li><p>把所有符号都组织在一张符号表中</p>
<blockquote>
<p>优点: 管理集中单一</p>
<p>缺点: 增加了空间开销</p>
</blockquote>
</li>
<li><p>根据符号属性相似程度分类组织成若干张表</p>
<blockquote>
<p>优点: 减少空间开销</p>
<p>缺点: 增加了表格管理的复杂性</p>
</blockquote>
</li>
</ul>
</li>
<li><p>符号表表项的排列</p>
<ul>
<li><p>线性组织</p>
<blockquote>
<p>优点：插入快，空间效率高；</p>
<p>缺点：查询慢，时间效率差。</p>
</blockquote>
</li>
<li><p>排序组织及二分法</p>
<blockquote>
<p>优点：查询效率高，<strong>空间效率高</strong>；</p>
<p>缺点：插入效率低，算法复杂一些。</p>
</blockquote>
</li>
<li><p>Hash表</p>
<blockquote>
<p>优点：插入、查询效率都高；</p>
<p>缺点：空间效率有所降低。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p><input disabled="" type="checkbox">  运行时空间组织</p>
<ul>
<li><p>实参传递给形参</p>
<ul>
<li>地址(变量传递地址,常数/表达式创建临时单元,传递临时单元的地址</li>
<li>传值(将值拿出来,放进被调用过程的形式单元中,使用时类似于使用局部变量</li>
<li>传名字</li>
</ul>
</li>
<li><p>函数值的返回</p>
<ul>
<li><p>将某个函数值保留在某个累加器中</p>
</li>
<li><p>/传递结果?</p>
<p>形参对应两个单元,实参地址+实参值.使用形式参数,对应使用第二个单元;</p>
</li>
</ul>
</li>
<li><p>活动记录的内容</p>
<ul>
<li>链接数据(返回地址/动态链/静态链)</li>
<li>形式单元(形式单元个数与内容)</li>
<li>局部数据区(局部变量/内情向量,即数组有关信息/临时工作单元)</li>
</ul>
</li>
<li><p>嵌套过程语言的栈式实现</p>
<ul>
<li><p>从下到上,内容依次是:</p>
<p>动态链(老SP),返回地址,静态链,形参个数,形参单元,局部变量,内情向量,临时单元</p>
</li>
<li><p>如果使用了嵌套层次显示表,其内容应该是:</p>
<p>动态链,返回地址,全局Display,形参个数,形参单元,display表,局部变量,内情向量,临时单元</p>
</li>
</ul>
</li>
<li><p>堆式内存分配</p>
<p>分配策略:</p>
<ul>
<li>首次满足法</li>
<li>最优满足法</li>
<li>最差满足法</li>
</ul>
</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox">  静态链和动态链</p>
<p>这里主要是关于静态链内容的确定方式:</p>
<p>静态链内容填写分为三种情况:</p>
<ul>
<li><p>第N层调用第N+1层,也就相当于父亲节点调用孩子节点</p>
<p>第N+1层的静态链填写调用过程 ( 第 N层过程 ) 的最新活动记录的起始地址 .也就相当于被调用者的静态链=<strong>调用者的SP</strong></p>
</li>
<li><p>第N层调用第N层,相当于兄弟节点调用其对应的兄弟节点</p>
<p>被调用者的静态链内容填写为 调用过程 ( 第 N层过程 ) 的静态链的值。也就是被调用者静态链=<strong>调用者的静态链.</strong></p>
</li>
<li><p>第N层调用第N-X层</p>
<p>相当于第某一个后代节点调用其祖先节点.</p>
<p>被调用者的静态链填写需要<strong>沿着调用者的静态链跳转X次</strong>到达的活动记录的静态链内容,即被调用者的静态链内容.</p>
</li>
</ul>
</li>
</ul>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul>
<li><p><strong>词法分析,给定正规式</strong></p>
<blockquote>
<p>构造NFA<br>确定化<br>最小化</p>
</blockquote>
<h2 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h2><ul>
<li><p>经常用到的表现形式: <strong>状态转换图</strong></p>
<ul>
<li><p>使用<strong>结点表示状态</strong>,用<strong>圆圈</strong>表示</p>
</li>
<li><p>状态之间使用箭弧链接,上面的数字代表射出节点状态下可能出现的状态.</p>
</li>
<li><p>一张转换图只包含有限个状态,<strong>必然有一个为初态</strong>,<strong>至少有一个终态</strong>.</p>
</li>
<li><p><strong>初态要添加箭头</strong>指向表示,<strong>终态使用双圆圈</strong>表示.</p>
</li>
<li><p>注意到,如果判定时需要添加一个额外的符号来表示转换到终结态,那终结态应该还要退还这个多输入的额外的符号给输入串.使用<strong>终态节点上打星号</strong>代表多读入了一个不属于标识符的字符.</p>
<img src="https://s2.loli.net/2022/06/14/9ZLupBGYzcJRC6i.png" alt="image-20220612133236416" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><ul>
<li><p>什么是DFA</p>
<p>一个确定有限自动机使用五元式来表示 $M=(S,\Sigma,\delta,s_0,F)$</p>
<p>其中各个内容的含义:</p>
<ul>
<li><p>S: 一个有限集,每个元素代表一个状态</p>
</li>
<li><p>$\Sigma$: 有穷字母表,每个元素代表一个输入字符</p>
</li>
<li><p>$\delta$: 是从$S \times \Sigma$到$S$的单值映射,$\delta (s,a)=s’$代表当 当前状态为s,输入为a时,将转换到下一个状态s’, s’又被称为后继状态.</p>
</li>
<li><p>$s_0 \in S$, 代表<strong>唯一的初态</strong>.(<strong>确定有限自动机初态唯一</strong>)</p>
</li>
<li><p>$F\subseteq S$,是一个终态集,(<strong>可以为空集</strong>)</p>
</li>
</ul>
<p>综合来说,就是(状态集,输入集,转换关系,初态,终态集)</p>
</li>
<li><p>一个DFA可以表示为一张状态转换图(最左侧列代表状态),最上面行代表输入.</p>
<p>若M的初态结点同时又是终态结点，则空字𝜀可为M所识别（或接受）</p>
</li>
<li><p><strong>DFA的构造问题:给定一个正规式,将其转化DFA</strong></p>
</li>
<li><p>优缺点:</p>
<p>编程实现容易,效率高,但是构造困难</p>
</li>
</ul>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><ul>
<li><p>关于非确定有限自动机NFA</p>
<p>基本同上,同样使用五元式进行表示,不过不同的是:</p>
<ul>
<li><p>原本的$\delta$代表的单值映射,这里是$S \times \Sigma^* 到S$的<strong>子集</strong>的映射.也就是<br>$$<br>\delta:S \times \Sigma^{*} \rarr 2^{S}<br>$$</p>
</li>
<li><p>原本的初态是唯一的,这里的初态是<strong>非空初态集</strong></p>
</li>
<li><p>另外,在这里的弧上可以出现空字**$\epsilon$**</p>
</li>
</ul>
</li>
<li><p><strong>从一个正规式转化为NFA</strong></p>
</li>
<li><p><strong>给定一个NFA,如何将其转化为正规式</strong></p>
</li>
<li><p>优缺点</p>
<p>NFA构造比较容易,但是编程实现有回溯</p>
</li>
</ul>
<h2 id="NFA的确定化-转变为DFA"><a href="#NFA的确定化-转变为DFA" class="headerlink" title="NFA的确定化(转变为DFA)"></a>NFA的确定化(转变为DFA)</h2><ul>
<li><p>使得初态和终态唯一(引入新的初态X和终态Y).</p>
<p>从𝑋 到𝑆0 的任意状态结点连一条𝜀箭弧；</p>
<p>从𝐹中的任意状态结点连一条𝜀箭弧到𝑌。</p>
</li>
<li><p>分裂</p>
<p>使得每条箭弧上或为$\epsilon$ ,或者是$\Sigma$中的单个字符</p>
<img src="https://s2.loli.net/2022/06/14/azZdQeVgf3Kbnos.png" alt="image-20220612160632690" style="zoom:67%;" /></li>
<li><p>寻找可合并状态</p>
<p>引入闭包的概念,定义I的ε闭包ε_Closure(I)为：</p>
<p>➢ 若𝑞 ∈ 𝐼，则𝑞 ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)； </p>
<p>➢ 若𝑞 ∈ 𝐼, 𝛿(𝑞, 𝜀) = 𝑞′，则𝑞′ ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)。(也即是从闭包内的状态接受空字可以转移到的状态)</p>
<p><strong>具体过程步骤:</strong></p>
<img src="https://s2.loli.net/2022/06/14/YwEpAqB8FsrJCRW.png" alt="image-20220612161011278" style="zoom:67%;" /></li>
<li><p>状态合并</p>
<p>➢ 每个状态子集视为新的状态； </p>
<p>➢ <strong>初态为首行首列；</strong> (而不是含有初态的就是初态!)</p>
<p>➢ <strong>终态是含有原终态的状态子集。</strong></p>
</li>
</ul>
<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2><ul>
<li><p>定义等价状态</p>
<ul>
<li><p>如果从𝑠出发能读出某个字𝑤而停在终态，那么从𝑡出发也能读出字𝑤停在终态；</p>
</li>
<li><p>如果从𝑡出发能读出某个字𝑤而停在终态，那么从𝑠出发也能读出字𝑤停在终态。</p>
</li>
</ul>
</li>
<li><p>可区别状态</p>
<ul>
<li>终态和非终态 可区别的</li>
<li>射出弧不同(一个有a,一个没有a) 可区别的</li>
<li>通过同样的输入得到的输出是可区别的  可区别的</li>
<li>通过某个输入到达的状态及其等价状态,对另一个来说使用某个输入是不可到达的  可区别的</li>
</ul>
</li>
<li><p>化简时,首先从<strong>终态与非终态的区分</strong>开始</p>
<p>每次都要检查原本同一个集合中的元素得到相同的输入后的输出是否在同一个集合中.如果不,将两者剥离.</p>
</li>
<li><p>化简后的弧的创建:</p>
<img src="https://s2.loli.net/2022/06/14/e9wCyIgutAvmrJY.png" alt="image-20220612171255023" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><ul>
<li><p><strong>LL(1)分析,给出文法</strong></p>
<blockquote>
<p>构造First集合<br>否则Follow集合<br>构造LL(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>LL(1)文法中<strong>最重要的两个概念</strong>:</p>
<ul>
<li>终结首符集 (头符号集)</li>
<li>后继终结符号集(后继符号集)产生原因在于对空字进行匹配时,需要依据这里的判断来决定是否要进行匹配.</li>
</ul>
<p>进行LL(1)分析时,需要满足的条件如下,满足以下条件,才称之为LL(1)文法:</p>
<blockquote>
<p>L: From <code>L</code>eft to Right</p>
<p>L: 最左推导</p>
<p>1: 分析一步,看右侧的一个符号</p>
</blockquote>
<ul>
<li><p>文法不含左递归；  –<code>不含有左递归</code></p>
</li>
<li><p>对𝐴 → 𝛼1| … |𝛼𝑛的每对候选式，有𝐹𝑖𝑟𝑠𝑡 (𝛼𝑖) ∩ 𝐹𝑖𝑟𝑠𝑡(𝛼𝑗) = ∅，其中𝑖 ≠ 𝑗；  <code>同一个推导式的右侧首符集无公用元素</code></p>
</li>
<li><p>对非终结符号𝐴，**若𝜀 ∈ 𝐹𝑖𝑟𝑠𝑡(𝐴)**，有𝐹𝑖𝑟𝑠𝑡 (𝐴) ∩ 𝐹𝑜𝑙𝑙𝑜𝑤 (𝐴) = ∅。 <code>同一个非终结符的首符集与后继符号集不相交</code>。</p>
<p><strong>对与First集合中不含有空字的，无论其First集合与Follow集合相交是否为空，都不影响判断这个文法是否是LL(1)文法。</strong></p>
</li>
</ul>
<p>分析时:</p>
<img src="https://s2.loli.net/2022/06/14/5M6sg8SJtnvGRap.png" alt="image-20220614093624431" style="zoom:67%;" />



<p><strong>First集合的求解:</strong></p>
<img src="https://s2.loli.net/2022/06/14/GE6m7nKSahcukLA.png" alt="image-20220614093824988" style="zoom:80%;" />

<p>向首符集中添加空字\epsilon的条件: </p>
<ul>
<li>明确说明了从X能直接推导 epsilon</li>
<li>对于X推导出的某一串连续的非终结符,这一串非终结符都含有空字epsilon</li>
</ul>
<p>对于<strong>Follow集合</strong>:</p>
<ul>
<li><p>特别地一个终结符<code>#</code>,在S所在的推导式的右侧添加<code>#</code>,进而为对应的非终结符提供Follow集合中的<code>#</code></p>
</li>
<li><p>具体求解</p>
<img src="https://s2.loli.net/2022/06/14/jEIOKosknHblWA1.png" alt="image-20220614094603428" style="zoom:80%;" /></li>
</ul>
<p><strong>构造LL(1)分析表</strong></p>
<img src="https://s2.loli.net/2022/06/14/cOg9BvlFPeHo2S4.png" alt="image-20220614095418380" style="zoom:80%;" />

<p>表格的格式如下所示:</p>
<table>
<thead>
<tr>
<th></th>
<th>$V_{T1}$</th>
<th>$V_{T2}$</th>
<th>$\cdots$</th>
<th>#</th>
</tr>
</thead>
<tbody><tr>
<td>$V_{N1}$</td>
<td></td>
<td></td>
<td></td>
<td><strong>千万不要忘记!</strong></td>
</tr>
<tr>
<td>$V_{N2}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$V_{N3}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>分析过程</strong></p>
<img src="https://s2.loli.net/2022/06/14/2T7zDNJRMOHaklq.png" alt="image-20220614095609097" style="zoom: 80%;" />

<p>进行分析时的表格格式如下所示:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>文法符号栈</th>
<th>输入串</th>
<th>所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h3><ul>
<li><p><strong>LR分析,给出文法</strong></p>
<blockquote>
<p>构造拓广文法<br>构造拓广文法的LR(0)/LR(1)项目集规范族<br>构造LR(0)/LR(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>分析法的优点:</p>
<ul>
<li>多数上下文无关文法描述的语言都可以使用LR分析器识别.</li>
<li>LR能分析的文法包括LL(1)能分析的文法.</li>
<li>扫描输入串时可以发现任何错误,并能准确指出出错地点.</li>
</ul>
<p>常见的LR分析四种方法包括:</p>
<ul>
<li>LR(0)分析法,局限性大</li>
<li>简单LR(SLR)</li>
<li>规范LR</li>
<li>向前LR(LALR)</li>
</ul>
<h3 id="定义LR文法以及相关概念"><a href="#定义LR文法以及相关概念" class="headerlink" title="定义LR文法以及相关概念"></a>定义LR文法以及相关概念</h3><ul>
<li><p>LR文法:文法能够构造一个LR分析表,使得其每一个入口都唯一</p>
</li>
<li><p>规范句型: 包含句柄的可规约句型</p>
</li>
</ul>
<h3 id="LR（0）分析法"><a href="#LR（0）分析法" class="headerlink" title="LR（0）分析法"></a>LR（0）分析法</h3><p>需要注意一点: $A\rarr \epsilon$只有一个状态$A\rarr \dot{}$</p>
<p>分析过程:</p>
<ol>
<li><p>首先构造拓广文法</p>
<p>也就是$G_1=(V_T,V_N,S,P)$构造为$G_2=(V_T,V_N ∪{S’},S’,P∪{S’ \rarr S})$</p>
<p>我们称G2是G1的拓广文法.</p>
</li>
<li><p>构造拓广文法的LR(0)项目集规范族</p>
<p>这里需要使用到闭包的相关概念.</p>
</li>
<li><p>构造分析表</p>
</li>
<li><p>识别句子</p>
</li>
</ol>
<p>认为SLR与LR(1)的主要区别在于:</p>
<p>SLR避免冲突的方式,是对整个文法中每个非终结符求取其对应的FOLLOW集合内容,从而得到对应的后继终结符,根据决定规约/移进时,对应规约式规约后的非终结符的FOLLOW集合中是否含有下一个要移入的终结符来判断是否选择规约.</p>
<p>而LR(1)的方法相较于SLR更加细化,也就是其根据的不是宽泛的整个语法中的FOLLOW集合,而是单纯根据对应推导式的FOLLOW集合,具体是指对应<code>·</code>所在的位置后面,看作一个整体,看其整体的FIRST集合.</p>
<p>三者的差别反映在分析表的构造上:</p>
<ul>
<li><p>对于LR(0),如果<code>·</code>到达了式子的末尾,那么对应在分析表的所有终结符对应位置都要填写规约式.</p>
</li>
<li><p>对于SLR,只在规约后的非终结符的FOLLOW对应的终结符的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/SOoJrq8fWihBDCK.png" alt="image-20220614223033464"></p>
</li>
<li><p>对于LR(1),在对应<code>·</code>在式子末尾时,式子的<code>前瞻符号</code>的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/QAOpidHvRF6oqnD.png" alt="image-20220614223001637"></p>
</li>
</ul>
</li>
</ul>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><ul>
<li><p><strong>给出翻译模式和高级语言程序，翻译句子</strong></p>
<blockquote>
<p>一般涉及<strong>多种类型句子</strong>的综合，也可能涉及<strong>声明语句填写符号表</strong>。</p>
</blockquote>
<p>进行翻译时,这里给出几种方法:</p>
<ul>
<li><p>第一种就是按部就班按照PPT给定的方式进行翻译:</p>
<p>首先根据产生式写出LR(0)分析表,确定运算的优先次序.</p>
<p>其次按照LR(0)分析,对给定的程序输入串进行分析规约.同时通过设定好的语义规则产生中间代码.</p>
</li>
<li><p>第二种,直接写语法树</p>
<p>问题在于需要确定运算时的优先级设定.</p>
<p>如果优先级确定没问题,那么最终结果应该也没问题.</p>
</li>
</ul>
<p><strong>翻译时,一定务必搞清楚跳转关系啥的!!!</strong></p>
<img src="https://s2.loli.net/2022/06/16/Jbc7FtWjsyxV4ga.png" alt="image-20220616212008779" style="zoom:80%;" />

 

<p>几种常见的类型的句子的翻译:</p>
<ul>
<li><p>布尔</p>
</li>
<li><p>控制</p>
</li>
<li><p>说明</p>
<p>这里说明语句,主要是在符号表中填写,主要填写内容包括:名字\类型\字宽等信息.</p>
<blockquote>
<p>① 过程中的说明语句形式：𝑖𝑑1, 𝑖𝑑2, … , 𝑖𝑑𝑛 ∶ 𝑡𝑦𝑝𝑒</p>
<p>② 每个变量需要记录名字、类型、字宽信息，分别用属性name、type、width记录</p>
<p>③ 当新出现一个名字时，需要记录进符号表，用offset记录该名字在符号表中的地址偏移量，在识别前置初值为0 。 </p>
<p>④ 过程enter(name, type, offset)用来把名字name填入到符号表，并给出该名字的类型type及在过程数据区中的相对地址offset。 </p>
<p>⑤ 假定整数类型域宽为4，实型域宽为8。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="DAG优化"><a href="#DAG优化" class="headerlink" title="DAG优化"></a>DAG优化</h3><ul>
<li><p><strong>给出基本代码块</strong></p>
<blockquote>
<p><strong>对于给定的基本块构造DAG</strong></p>
<p><strong>按照构造DAG的节点顺序重新写中间代码</strong></p>
<p><strong>利用节点排序算法对节点排序,并根据排序后的节点顺序写中间代码</strong></p>
<p><strong>对上一步的中间代码利用简单代码生成算法生成目标代码</strong></p>
<blockquote>
<p>写出优化后的中间代码<br>写出DAG目标优化后的中间代码<br>根据变量活跃性和寄存器信息，写出目标代码</p>
</blockquote>
</blockquote>
<p>基础的内容暂且不表.</p>
<h3 id="代码块划分"><a href="#代码块划分" class="headerlink" title="代码块划分"></a>代码块划分</h3><ul>
<li>开始<ul>
<li>整个代码的开头</li>
<li>跳转语句所能到达的位置</li>
<li>在条件跳转语句之后的第一条语句</li>
</ul>
</li>
<li>结束<ul>
<li>另一个开头</li>
<li>转移代码(包含</li>
<li>HALT指令(包含</li>
</ul>
</li>
</ul>
<h3 id="代码外提"><a href="#代码外提" class="headerlink" title="代码外提"></a>代码外提</h3><p>说一说代码外提的优化策略:</p>
<ol>
<li>首先要满足这是一个循环不变量</li>
<li>要提出去的循环不变量应该是出口节点B的<strong>必经节点</strong>/或者如果不是必经节点,那么循环之后<strong>不能再引用改定点值.</strong></li>
<li>循环不变量A=… 外提时,需要保证循环中的<strong>其它地方不再有A的定值点.</strong></li>
<li>循环不变量A=…外提时,要求循环中所有关于A的引用点都必须是且仅是这个定值点所能达到的.(也就是不能在要外提的定值点之前出现对A的引用.</li>
</ol>
<p>其次是查找循环L中的不变量的算法:</p>
<ol>
<li>依次查看每个L的每个基本块的代码,如果其运算对象为常数,或者定值点在L之外,将这个代码标记为不变运算.</li>
<li>重复后面一一步,直到没有新的代码被标记为不变运算</li>
<li>依次查看没有被标记为不变运算的代码,如果它的每个运算对象或为常数，或者定值点在L之外，或只有一个能到达的定值点且该点上的代码已标记为“不变运算”，则把查看的代码标记为“不变运算”.</li>
</ol>
<p><strong>代码外提算法</strong></p>
<ol>
<li>寻找不变运算</li>
<li>判断能否外提</li>
<li>按照顺序依次外提</li>
</ol>
<h3 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h3><p>完成将循环内的每次的线性乘法分解成循环外的初始赋值和循环内的加法.</p>
<p>将变量更换为常量.</p>
<h3 id="目标代码的生成设定"><a href="#目标代码的生成设定" class="headerlink" title="目标代码的生成设定"></a>目标代码的生成设定</h3><ul>
<li><p>相关设定</p>
<p> ➢ 建立一个编译时用的寄存器描述数组𝑅𝑣𝑎𝑙𝑢𝑒，动态地记录各寄存器的上述信息</p>
<p>➢ 建立一个变量地址描述数组𝐴𝑣𝑎𝑙𝑢𝑒，动态地记录各变量现行值的存放位置：是寄存器中，还是某主存单元，还是既在寄存器又在主存单元。</p>
</li>
<li><p>寄存器获取</p>
<ol>
<li><p>如果<strong>𝐵存放在某个寄存器𝑅𝑖</strong>，𝑅𝑣𝑎𝑙𝑢𝑒[𝑅𝑖]<strong>只包含𝐵</strong>，同时，或者𝐵与𝐴是<strong>同一标识符</strong>，或者中间代码𝑖中𝐵的信息为(−, −)（即<strong>后面不再引用</strong>），则选取𝑅𝑖为所需寄存器，转(4)。</p>
<p>(三个条件必须同时满足才行:在寄存器中,只包含,后续不用/同一标识符)</p>
</li>
<li><p>如果(1)失败，若有空闲寄存器𝑅𝑖，选择其作为所需寄存器，转(4)。</p>
</li>
<li><p> 若(2)也失败，需要从已分配寄存器中选择𝑅𝑖：</p>
</li>
</ol>
<p>   占用该𝑅𝑖的变量也保存在<strong>主存</strong>中，或者在最远的地方被引用（即待用信息值最大）。</p>
<ol start="4">
<li><p>对𝑅𝑣𝑎𝑙𝑢𝑒[𝑅𝑖]中的每个变量𝑀，如果𝑀 ≠ 𝐴，或者𝑀 = 𝐴 = 𝐶 ≠ 𝐵 ∧ 𝐵 ∉𝑅𝑣𝑎𝑙𝑢𝑒[𝑅𝑖]，则：</p>
<p>① 如果𝑀 ∉ 𝐴𝑣𝑎𝑙𝑢𝑒[𝑀]，生成目标代码𝑆𝑇 𝑅𝑖, 𝑀； </p>
<p>② 如果𝑀 = 𝐵，或者𝑀 = 𝐶 ∧ 𝐵 ∈ 𝑅𝑣𝑎𝑙𝑢𝑒[𝑅𝑖]，则令𝐴𝑣𝑎𝑙𝑢𝑒 𝑀 = {𝑀, 𝑅}，否则</p>
<p>令𝐴𝑣𝑎𝑙𝑢𝑒 𝑀 = {𝑀}； </p>
<p>③ 删除𝑅𝑣𝑎𝑙𝑢𝑒[𝑅𝑖]中的𝑀； </p>
<p>④ 给出𝑅，返回。</p>
<blockquote>
<p>当前已经拿到了要分配的寄存器了,但是不确定要不要将寄存器内容写内存,因此需要判断:</p>
</blockquote>
</li>
</ol>
</li>
<li><p>名词</p>
<p>指令执行代价:：每条指令的执行代价 = 每条指令访问主存单元次数 + 1</p>
</li>
</ul>
<h3 id="DAG的目标代码"><a href="#DAG的目标代码" class="headerlink" title="DAG的目标代码"></a>DAG的目标代码</h3><p>算法详情:</p>
<img src="https://s2.loli.net/2022/06/17/ov3VCX5HmYnhRQd.png" alt="image-20220617220741228" style="zoom:80%;" /></li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul>
<li><p>构造语言</p>
<p>给出语言$L(G)={a^{m}b^{n}|1&lt;=n&lt;=m&lt;=2n}$,  请构造对应文法.</p>
<p>答:<br>$$<br>G(S):\<br>S=ab | aab\<br>S=aSb | aaSb<br>$$</p>
</li>
<li><p>作业题</p>
<img src="https://s2.loli.net/2022/06/14/oYXO7H5rIswWVJm.png" alt="image-20220612004824158" style="zoom:67%;" /></li>
</ul>
<h3 id="第七章优先级"><a href="#第七章优先级" class="headerlink" title="第七章优先级"></a>第七章优先级</h3><img src="https://s2.loli.net/2022/06/17/rRo9Azd7u6QyWEF.png" alt="image-20220617102749876" style="zoom:80%;" />



<h3 id="第七章说明"><a href="#第七章说明" class="headerlink" title="第七章说明"></a>第七章说明</h3><img src="https://s2.loli.net/2022/06/17/PYVbLByiJksv8jT.png" alt="image-20220617103328274" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/17/QJNfoezWU1E8L7C.png" alt="image-20220617103349846" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/17/imLWuJysMgYtAp1.png" alt="image-20220617103601530" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/17/xvaZL51NJn4M9CS.png" alt="image-20220617103633347" style="zoom:80%;" />


    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <p><h4>© 2021 Baxkiller Powered By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="db91ONAaJE7csgIBIIeWxEXK-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="V4ivekKhnC8pvzwTKL40Pnx8">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
