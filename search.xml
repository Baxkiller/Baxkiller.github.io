<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Force-Layout算法相关学习</title>
    <url>/2021/12/07/Force-Layout%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="力导图"><a href="#力导图" class="headerlink" title="力导图"></a>力导图</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul>
<li><p>给定一个社交网络的例子.</p>
<blockquote>
<p>In the case of network visualization, we compute the layout using a similar physical simulation: nodes in the network act as charged particles that repel each other, while links act as springs that pull related nodes together.</p>
</blockquote>
<p>也就是,我们认为,在社交网络中,节点之间的相互作用是相当于<strong>带电粒子之间的相互斥力</strong>,而节点之间的连线是<strong>相当于弹簧的拉力,将两个节点聚拢引力.</strong></p>
</li>
<li><p>带来的缺点</p>
<p>用这种方法需要计算任意两个点之间的相互作用力,花费时间更多.达到O(n^2^)级别.这样每次增加一个点,都需要进行大量的冗余计算.(因为存在一些点距离新添加点的距离非常相近,计算结果大致相同)</p>
</li>
</ul>
<h2 id="Barnes-Hut-Approximation-BH近似"><a href="#Barnes-Hut-Approximation-BH近似" class="headerlink" title="Barnes-Hut Approximation(BH近似)"></a>Barnes-Hut Approximation(BH近似)</h2><ul>
<li><p>具体想法是通过将一组远距离点看作一组,以其质心到给定点的力去近似这一组点的作用力.</p>
<p>此方案将计算的时间复杂度由O(n^2^)提高到了O(n logn).</p>
<blockquote>
<p>The key idea is to approximate long-range forces by replacing a group of distant points with their center of mass. </p>
</blockquote>
<p>这种近似的核心是一个空间索引,将一组点抽象成一个单一的质点.在二维空间,使用四叉树去将二维空间递归分割,对应到三维空间,就是使用八叉树将空间递归分割.(想象三维坐标系中的三个坐标平面将整个空间八等分).</p>
</li>
<li><p>步骤(二维空间为例)</p>
<ol>
<li>通过四叉树,构建空间索引</li>
<li>计算质心</li>
<li>模拟力</li>
</ol>
</li>
<li><p>接下来进行具体分析,具体链接参见<a href="https://jheer.github.io/barnes-hut/">The Barnes-Hut Approximation (jheer.github.io)</a>,</p>
<h3 id="构建四叉树"><a href="#构建四叉树" class="headerlink" title="构建四叉树"></a>构建四叉树</h3><p>构建四叉树具体参见上述链接中的其中<code>Step1</code>,拖动<code>bar</code>进行动态化演视</p>
<p>总而言之可以分为如下的部分:</p>
<ul>
<li> 初始给定一个点,确定该点所在的位置(一定位于最开始的四大块之一)</li>
<li> 后续给定点,判断其是否在当前已经划分好的方格内且自己独占一格不与其他点公用一格,如果不是,继续向下划分,直到这个新给定的点独自在一个方格内.</li>
<li> 到最后,每个点都有独属于自己的小方格.小方格的大小代表该点在四叉树中的层数.小方格越小,层数越深.</li>
</ul>
<h3 id="计算质心"><a href="#计算质心" class="headerlink" title="计算质心"></a>计算质心</h3><p>一个单元格的质心,是它的四个子单元格质心的加权平均.     </p>
<p>进行计算时,选择从最底层的叶子节点逐级向上进行遍历.</p>
<p>当遍历结束,每个单元格都有了其自己的质心位置和大小(权重信息).</p>
<h3 id="模拟N体力"><a href="#模拟N体力" class="headerlink" title="模拟N体力"></a>模拟N体力</h3><p>具体参见<a href="https://jheer.github.io/barnes-hut/#:~:text=Rather%20than%20compute%20interactions%20among%20individual%20points%2C%20we%20can%20compute%20interactions%20with%20centers%20of%20mass%2C%20using%20smaller%20quadtree%20cells%20for%20nearer%20points%20and%20larger%20cells%20for%20more%20distant%20points.">链接</a></p>
<blockquote>
<p>Rather than compute interactions among individual points, we can compute interactions with centers of mass, <strong>using smaller quadtree cells for nearer points</strong> and <strong>larger cells for more distant points</strong>.</p>
<p>At this point we’ve skipped a critical detail: what constitutes “long-range” versus “short-range” forces? We consider both the <em>distance</em> to the center of a quadtree cell and that cell’s <em>width</em>. If the ratio <em><strong>width / distance</strong></em> falls <strong>below</strong> a chosen threshold (a parameter named <em><strong>theta</strong></em>), we treat the quadtree cell as a source of **long-range **forces and use its center of mass. Otherwise, we will recursively visit the child cells in the quadtree.</p>
</blockquote>
<p>相较于计算个体之间的作用力,这里我们更倾向于通过质心进行计算.</p>
<p>对于要进行计算的质心选择:例如给定一个任意点<code>A</code>,我们依次从最高层到下层去遍历单元格中心到给定点<code>A</code>的距离.将当前遍历到的单元格长度<code>width</code>与这个单元格中心到<code>A</code>的距离<code>distance</code>相除.</p>
<ul>
<li>如果<strong>小于</strong>一个给定参数<strong>theta</strong>,我们认为<code>distance</code>更大,因此要使用该单元格的质心去近似.并且不再对该单元进行更深层的子单元格递归判断.</li>
<li>如果<strong>大于</strong>一个给定参数<strong>theta</strong>,认为<code>distance</code>较小,因此要继续向下,判断该单元格的子单元格.判断方式同上.直到到达一个点.</li>
</ul>
<p>判断远近的条件是通过判断 <strong>被遍历单元格中心/单元格到给定点的距离</strong>,当距离越近,这个值越大,就越容易被认为是相近点,越要向下细分.</p>
</li>
</ul>
<h2 id="表现分析"><a href="#表现分析" class="headerlink" title="表现分析"></a>表现分析</h2><p>从运行时间和力模拟的精确度两个方向进行分析.</p>
<ul>
<li><p>运行时间</p>
<ul>
<li><p>数据集大小:500-10000.</p>
</li>
<li><p>更改参数:theta</p>
</li>
<li><p>每组数据集中测试次数:50次</p>
</li>
</ul>
<img src="https://img-blog.csdnimg.cn/0da2177bc1bd459689a2ddfd2812b9ff.png" alt="image-20211029003544107" style="zoom:67%;" />

<ul>
<li><p>结论</p>
<p>确实可以提高速度.并且随着参数<code>theta</code>增大,运行速度增快.</p>
<p>初始的方法其实可以看做是<code>theta=inf</code>的特殊情况.这样每个点都要精确到本身而不是单元格.</p>
</li>
</ul>
</li>
<li><p>近似误差</p>
<ul>
<li><p>纵坐标代表初始算法结果与<code>BH近似</code>的结果之间的像素点位置差异值</p>
<img src="https://img-blog.csdnimg.cn/f1ed97a559d24538a1f58c2d18599a5a.png?" alt="image-20211029004310133" style="zoom: 67%;" /></li>
<li><p>结论</p>
<p>上述给出的是平均误差,虽然最大之后5%左右,但具体到某个点上,误差可能很大.因此还应关注最大误差值.</p>
<p>相对而言,<code>theta=1</code>的效果最好.(默认值)</p>
<blockquote>
<p>These results suggest that a good default value for theta — with low running time <em>and</em> low approximation error — is around 1.0. Indeed</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最后的结论就是该算法相当棒!:thumbsup:</p>
]]></content>
      <tags>
        <tag>CLASS,ALGORITHMS</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubDesktop与Hexo组合更新博客</title>
    <url>/2021/12/08/GithubDesktop%E4%B8%8EHexo%E7%BB%84%E5%90%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>首先是使用<code>Hexo</code>的命令时,先放一些常用的简单命令在这里:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure>

<p>如果对于我们自己的页面添加新的博客或者做出新的改动时,除了通过本地服务器进行查看之外,如果想要同步更新到远程仓库,就需要通过<code>Hexo d</code>将当前生成的全部页面内容更新到Github上面.但是由此产生的问题是,如果你将你自己的域名指向了你的Github-Page,那么每当部署一次内容,就需要重新设定一次Github-Page的个性域名,很是麻烦.</p>
<p>虽然看网上的教程中提到,可以通过在整个博客文件下的<code>source</code>文件中添加文件<code>CNAME</code>,内容填写想要绑定的域名内容,但实际操作中发现其实并不管用.</p>
<p>由此我想到了当我使用Github时,对远程仓库进行更新,需要先将远程仓库拉取到本地,在本地做出更改后,再push到远程仓库.这个过程不需要对添加的域名映射进行更改.而是直接<code>push</code>就好.</p>
<h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本内容适用于:</p>
<ul>
<li><p>主机<code>Windows10</code>(或许其他也可以,但是笔者并未尝试过</p>
</li>
<li><p>已经在本地安装好<code>Hexo</code>,<code>Git</code>以及<code>GithubDesktop</code>的主机.</p>
</li>
<li><p>已经选择好主题并且将其克隆至本地文件夹的主机.</p>
</li>
</ul>
<p>如果你还没有安装好<code>Hexo</code>,这里提供友链以供安装使用:</p>
<p><a href="https://zhuanlan.zhihu.com/p/60578464#">使用 Hexo+GitHub 搭建个人免费博客教程</a></p>
<p>以及安装<code>Git</code>的教程:</p>
<p><a href="https://blog.csdn.net/mukes/article/details/115693833">Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装</a></p>
<p><strong>检查:</strong></p>
<p>通过命令行进行安装确认和检查:</p>
<p><img src="https://img-blog.csdnimg.cn/c25d74ff75d44ba199806eb79430f54f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmF4a2lsbGVy5pyJ5Y-q54yr,size_8,color_FFFFFF,t_70,g_se,x_16" alt="image-20211208150728331"></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>如果下载安装好了主题,那么博客文件夹的内容应该如下所示:</p>
<p><img src="https://img-blog.csdnimg.cn/e32cf484c7cb43be9fca9cce030a107f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmF4a2lsbGVy5pyJ5Y-q54yr,size_19,color_FFFFFF,t_70,g_se,x_16" alt="image-20211208133924041"></p>
<p>有些许的不同是正常的,不需要特别在意.</p>
<p><strong>理论:</strong></p>
<ul>
<li>方便起见,上面文件我们暂且将其命名为<code>根文件</code>.其路径<code>D:\Github_Hexo_test</code>命名为根路径.</li>
<li>根文件中的<code>public</code>文件,是通过调用<code>hexo g</code>生成的真正需要上传到远程仓库的内容.</li>
<li>每次通过<code>GithubDesktop</code>克隆下来的远程库的内容正是上次上传的内容.</li>
<li>修改<code>public</code>文件并不会影响在根文件中运行<code>hexo g</code>命令生成新的页面内容</li>
<li><code>GithubDesktop</code>会自动检测克隆到本地库的文件的更改内容,然后可以将更改<code>push</code>到远程仓库.</li>
</ul>
<p><strong>实践:</strong></p>
<ul>
<li><p>将当前根文件中的<code>public</code>文件做备份<code>public-1</code>,将<code>public</code>文件删除.</p>
</li>
<li><p>打开<code>GithubDesktop</code>,将远程仓库<code>github.username.io</code>克隆至<code>根路径\public</code>.</p>
<p>注意:warning::这里一定不要直接在<code>Explorer</code>中新建,而是在下面路径中输入<code>根路径\public</code>.</p>
<p>示例:</p>
<img src="https://img-blog.csdnimg.cn/3cd54a7c36e54f72b102333bc4d91907.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmF4a2lsbGVy5pyJ5Y-q54yr,size_14,color_FFFFFF,t_70,g_se,x_16" alt="image-20211208150242881" style="zoom: 67%;" /></li>
<li><p>点击<code>Clone</code>,等待克隆完成.</p>
</li>
</ul>
<p>至此,整个流程基本结束.</p>
<p><strong>检验:</strong></p>
<p>接下来通过创建一篇新的博客确认是否成功:</p>
<ul>
<li><p>在根目录下右键,选择<code>Git bash here</code>.</p>
</li>
<li><p>输入<code>hexo new &quot;xxx&quot;</code>,文件名xxx可以随便取,这里笔者使用<code>Visualization-HW2</code></p>
</li>
<li><p>进入<code>根路径\source\_posts\xxx.md</code>,在内容中随便输入任何内容都可.</p>
<p><img src="https://img-blog.csdnimg.cn/6cb1e0c954c249879208ee7533ec987f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmF4a2lsbGVy5pyJ5Y-q54yr,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image-20211208151051082"></p>
</li>
<li><p>关闭当前文件,重新在git命令行中输入<code>hexo g</code>生成.</p>
</li>
<li><p>打开<code>GithubDesktop</code>,可以发现会提示当前本地库发生改变.</p>
</li>
<li><p>在左下角输入提交名称,然后提交.</p>
</li>
<li><p>在上方选择<code>Push Origin</code>.</p>
</li>
<li><p>打开浏览器,查看自己的页面是否更新完成!</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>WEBSITE</tag>
      </tags>
  </entry>
  <entry>
    <title>Web_Crawlers</title>
    <url>/2022/02/06/Web-Crawlers/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Crawler"><a href="#Crawler" class="headerlink" title="Crawler"></a>Crawler</h1><h2 id="1-准备工作-查看对应的url"><a href="#1-准备工作-查看对应的url" class="headerlink" title="1. 准备工作 查看对应的url."></a>1. 准备工作 查看对应的<code>url</code>.</h2><p>发送请求路径后,返回的是一个<code>html</code>网页得源代码,将信息从网页源代码中提取出来.</p>
<p>对于网页资源得请求是持续得,而不是一下子就能够返回整个网页得.</p>
<p>使用谷歌浏览器,在控制台界面选择<code>NetWork</code>,选择时间轴上的信息,然后点击<code>Name</code>中选定的内容,出现的<code>Headers</code>就是<strong>我们发送给服务器</strong>的内容.具体<strong>服务器发送给本地</strong>的内容存在于<code>Headers</code>旁边的<code>Response</code>模块.</p>
<p><img src="https://s2.loli.net/2022/03/10/m7rnzebiwokZMTd.png" alt="P1"></p>
<p>其中的<code>Headers</code>中的内容,拉到最后,有一个<code>User-Agent</code>指代用户代理,也就是浏览器版本内容等等.</p>
<ul>
<li>表明当前浏览器可接受的界面类型对应的浏览器版本.例如上图中的<code>Mozilla</code>指代当前谷歌浏览器可以接受适配于<code>Mozila</code>浏览器的内容.</li>
<li>还可以表明当前计算机相关的内容,例如<code>Windows NT 10.0</code>代表当前使用的是<code>Win10</code>操作系统,64位版本.</li>
<li><code>Cookie</code>:想要爬取登录后才能查看的内容,必须先设置操作好<code>Cookie</code>.</li>
</ul>
<h2 id="2-层级结构"><a href="#2-层级结构" class="headerlink" title="2. 层级结构"></a>2. 层级结构</h2><p>根据控制台界面上特定元素的定位信息,来确定要爬取内容的层级结构.</p>
<p><img src="https://s2.loli.net/2022/03/10/lhPTqkLvns7Db4r.png" alt="P2"></p>
<h2 id="3-编码规范"><a href="#3-编码规范" class="headerlink" title="3. 编码规范"></a>3. 编码规范</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure>

<p>Python文件中可以加入main函数用于测试程序:</p>
<p>用来定义程序的入口地址或者说程序开始运行的第一个函数位置.相对更加清楚地看到程序地流程.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	<span class="comment"># 巴拉巴拉</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>引入外部库</p>
<p>引入本地生成的函数文件.</p>
<p>应当是从文件夹中引入文件.例如下图中,从文件夹<code>test1</code>中引入文件<code>t1</code>.</p>
<p>使用文件中的函数直接通过<code>.</code>运算符计科完成.</p>
<p><img src="https://s2.loli.net/2022/03/10/LqAYZFvnmaxQb85.png" alt="P3"></p>
<p>常用的是引入外部模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4 <span class="comment"># 网页解析获取数据</span></span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式,文字匹配</span></span><br><span class="line"><span class="keyword">import</span> urllib.request,urllib.error <span class="comment"># 指定url,获取网络数据</span></span><br><span class="line"><span class="keyword">import</span> xlwt <span class="comment"># 进行excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="comment"># 进行SQLite 数据库操作</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-整体流程"><a href="#4-整体流程" class="headerlink" title="4. 整体流程"></a>4. 整体流程</h2><ol>
<li><p>爬取网页</p>
</li>
<li><p>解析数据</p>
<p>数据解析通常是逐一解析数据,与爬取网页通常是共同存在的,同步地</p>
</li>
<li><p>保存数据</p>
</li>
</ol>
<h2 id="5-爬虫伪装"><a href="#5-爬虫伪装" class="headerlink" title="5. 爬虫伪装"></a>5. 爬虫伪装</h2><p>发送请求时对对象封装.</p>
<p>通常选择将发送<code>Request</code>对象中的<code>headers</code>设置为浏览器的样式.</p>
<h2 id="6-函数详解"><a href="#6-函数详解" class="headerlink" title="6. 函数详解"></a>6. 函数详解</h2><ul>
<li><p><code>askURL(url)</code> </p>
<p>返回单个<code>url</code>的页面内容.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬取指定一个url的网页信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askURL</span>(<span class="params">url, method = <span class="string">&quot;GET&quot;</span></span>):</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 &quot;</span></span><br><span class="line">                      <span class="string">&quot;Safari/537.36&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib.request.Request(url = url, headers = header, method = method)</span><br><span class="line">    html = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        responce = urllib.request.urlopen(req)</span><br><span class="line">        html = responce.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 判断是否含有属性`code`,也就是查看返回的错误信息是否是有代码例如`404`</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(e, <span class="string">&quot;code&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(e, <span class="string">&quot;code&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(e, <span class="string">&quot;reason&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(e, <span class="string">&quot;reason&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html</span><br></pre></td></tr></table></figure>

<p>返回的相当于是字符串.</p>
<p>该函数需要调用25次,来爬取25个范围.</p>
</li>
<li><p><code>getData(baseurl)</code></p>
<p>给定基本的<code>url</code>,例如本实验中是<code>&quot;https://movie.douban.com/top250?start=&quot;</code>,每次增加都只需要更改<code>start</code>的内容.</p>
<p>通过循环,爬取多个页面,每次都对爬取到的页面内容进行解码解析,将需要的内容存放在容器中,然后返回这个容器.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先是爬取每一个网页的内容</span></span><br><span class="line"><span class="comment"># 因为时循环爬取,所以这里仅给定循环中的内容</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	url=baseurl+<span class="built_in">str</span>(i*<span class="number">25</span>)</span><br><span class="line">	<span class="comment"># 获取url对应内容</span></span><br><span class="line">	pagecontent=askurl(url)</span><br><span class="line">	<span class="comment"># 对内容进行解析</span></span><br><span class="line">	soup=BeautifulSoup(pagecontentm<span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此时获取到的是<code>soup</code>,可以对内容进行解析筛选,得到我们想要的数据了.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 筛选内容</span></span><br><span class="line"><span class="comment"># 首先将所有要找的信息所在的大框架找到</span></span><br><span class="line"><span class="comment"># 例如本实例中,找到的信息都存在于&lt;div class=&quot;item&quot;&gt;中</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&quot;item&quot;</span>):</span><br><span class="line">    data = []  <span class="comment"># 一部电影的所有信息</span></span><br><span class="line">    item = <span class="built_in">str</span>(item)</span><br><span class="line">    <span class="comment"># 然后通过创建正则匹配模式,对想要的内容进行匹配</span></span><br><span class="line">    link = re.findall(findLink, item)[<span class="number">0</span>]  <span class="comment"># 此时找到的就是电影的详情页链接</span></span><br><span class="line">    imgSrc = re.findall(findImgSrc, item)[<span class="number">0</span>]</span><br><span class="line">    name = re.findall(findName, item)[<span class="number">0</span>]</span><br><span class="line">    otherName = re.findall(findOtherName, item)[<span class="number">0</span>].replace(<span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    rating = re.findall(findRating, item)[<span class="number">0</span>]</span><br><span class="line">    cnt = re.findall(findCnt, item)[<span class="number">0</span>]</span><br><span class="line">    info = re.findall(findInfo, item)[<span class="number">0</span>].strip().replace(<span class="string">&#x27;\xa0&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    quote = re.findall(findQuote, item)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(quote) == <span class="number">0</span>:</span><br><span class="line">    	quote = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        quote = quote[<span class="number">0</span>]</span><br><span class="line">    data.extend([link, imgSrc, name, otherName, rating, cnt, info, quote])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创造正则匹配表达,用来确定链接的位置</span></span><br><span class="line">findLink = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;</span>)</span><br><span class="line">findImgSrc = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;</span>, re.S)  <span class="comment"># re.S,匹配模式,包含换行符</span></span><br><span class="line">findName = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">findOtherName = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;other&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">findRating = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">findCnt = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span&gt;(\d*)人评价&lt;/span&gt;&#x27;</span>)</span><br><span class="line">findQuote = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)</span><br><span class="line">findInfo = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;p class=&quot;&quot;&gt;.*&lt;br/&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/10/4OMrd7qYg1U3TkF.png" alt="P8"></p>
</li>
</ul>
<h1 id="关于用到的库"><a href="#关于用到的库" class="headerlink" title="关于用到的库"></a>关于用到的库</h1><h2 id="整体库"><a href="#整体库" class="headerlink" title="整体库"></a>整体库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment"># 网页解析获取数据</span></span><br><span class="line"><span class="keyword">import</span> re  <span class="comment"># 正则表达式,文字匹配</span></span><br><span class="line"><span class="keyword">import</span> urllib.request,urllib.error <span class="comment"># 指定url,获取网络数据</span></span><br><span class="line"><span class="keyword">import</span> xlwt <span class="comment"># 进行excel操作</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="comment"># 进行SQLite 数据库操作</span></span><br></pre></td></tr></table></figure>



<h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a><code>urllib</code></h2><p><code>urllib</code>的作用是向另一端的服务器发送一个request,然后得到一个<code>responce</code>,这个收到的响应通常等价于上面提到的控制台中的<code>Responce</code>内容.</p>
<ul>
<li><p>一般用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用一个get的方式直接获得一个网址</span></span><br><span class="line">baseurl=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">responce=urllib.request().openurl(baseurl)</span><br><span class="line">temp=responce.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>最好是先解码(decode,decode会将原本的杂乱信息解码成一个比较规矩的信息)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过post方式发送请求获得响应</span></span><br><span class="line"><span class="comment"># 使用网站 httpbin.org</span></span><br><span class="line"><span class="comment"># 需要先提前引入 urllib.parse库</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;), encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">responce = urllib.request.urlopen(<span class="string">&quot;http://httpbin.org/post&quot;</span>, data = data)</span><br><span class="line"><span class="built_in">print</span>(responce.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>使用post 方式发送请求必须首先设置表单信息(二进制形式)</p>
<p>也就是信息的转换需要满足:</p>
<p>首先将内容通过编码,得到<code>utf-8</code>格式的数据,然后通过<code>bytes</code>转换成二进制.</p>
<p>信息-&gt;编码(通过<code>urllib.parse.urlencode(dict,encoding=)</code>,这里的encoding默认<code>utf-8</code>)-&gt;转换成二进制(通过<code>bytes(info,encoding=)</code>,这里的<code>encoding</code>显示说明且与前面的一致)</p>
<p>然后再调用<code>urllib.request.urlopen(baseurl,data=)</code></p>
<p>通过这种方式访问网站得到的信息,并没有经过伪装,因为此时的服务器接收到的内容仍然会显示当前的用户代理为<code>Python-urllib/3.9</code>而不是浏览器的信息.</p>
<p>伪装方法:发送请求时伪装<code>request.headers(User-Agent=)</code></p>
</li>
<li><p>超时控制</p>
<p>在<code>urllib.request.openurl(baseurl,timeout=)</code></p>
<p>设置时间上限,如果请求时间超过这个上限而没有接收到应答,停止接受和请求,直接返回一个错误.</p>
<p>如果在此时间到达之前就返回了响应结果,则没有啥问题.</p>
<p>在设置爬虫时,需要准备好如何面对超时的问题.例如如果超时,就不去爬取对应的页面.</p>
<p>可以等到最后再针对性处理</p>
</li>
<li><p>请求头解析</p>
<p>对于返回的<code>responce</code>,先不去直接<code>read</code>全部内容,而是直接选择性读取.</p>
<p>例如读取状态码:<code>responce.status</code>会输出获得到的返回状态码.</p>
<p>使用<code>responce.getheaders()</code>获得<strong>响应头</strong>信息,以列表形式返回.</p>
<p>获得状态头中的特定部分的信息:例如获取服务器信息<code>responce.getheaders(&quot;Server&quot;)</code></p>
<p>发送请求头:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&quot;USER&quot;</span>: <span class="string">&quot;ME&quot;</span>&#125;), encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">req = urllib.request.Request(url = url, data = data, headers = header, method = <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">response</span><br></pre></td></tr></table></figure>

<p>其中的<code>headers</code>中的用户代理信息来自与浏览器控制台</p>
<p>一般发送请求信息时,如果要伪装成了浏览器,只需要将用户头信息中的<code>Agent</code>改掉即可.</p>
<p>在这里的实验中,尝试通过更改<code>header</code>访问豆瓣,成功得到了所有的信息,然后将其进行解码并写入文件,可以得到最终的网页.</p>
<p><strong>注:</strong></p>
<p>在得到网页时,想要将其写入一个文件,但是报错:</p>
<p><img src="https://s2.loli.net/2022/03/10/QmPtgC94B8qNYKl.png" alt="image-20211130093347980"></p>
<p>搜索解决办法后,发现<a href="%5B%E3%80%90python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%EF%BC%8C%E4%BE%8B%E5%A6%82utf-8_%E8%8B%A5%E6%B0%B42018%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_42152399/article/details/80996451)">传送门</a>,然后进行了修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;Douban.html&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>更改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = codecs.<span class="built_in">open</span>(<span class="string">&quot;Douban.html&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果完全可行,将爬取到的内容全部写入了文件中.</p>
</li>
</ul>
<h2 id="bs4"><a href="#bs4" class="headerlink" title="bs4"></a><code>bs4</code></h2><ul>
<li><p><code>bs4.BeautifulSoup</code></p>
<p>按照选择的解析器,解析给定的二进制文件的内容.</p>
<p>例如当前有一个二进制文件<code>content</code></p>
<p>使用时:<code>bs=BeautifulSoup(content,&quot;html.parser&quot;)</code></p>
<p>其中的<code>&quot;html.parser&quot;</code>是指定解析器为解析<code>html</code>的内容.</p>
<p>使用时返回的<code>bs</code>是一个树形对象.</p>
<p>例如要获取其中的title信息,则使用<code>bs.title</code>,返回值为<code>&lt;title&gt;豆瓣&lt;/title&gt;</code></p>
<p>如果不想要标签存在的话,增加一个<code>bs.title.string</code>,返回<code>豆瓣</code></p>
<p>问题是,<strong>每次都只会返回找到的第一个给定类型的标签</strong>.</p>
<ul>
<li><p>获取title信息</p>
<p><code>bs.title</code></p>
</li>
<li><p>获取某标签的属性信息</p>
<p><code>bs.a.attrs</code></p>
<p>返回的是字典类型,每一个名称对应一个键值,例如:</p>
<p><img src="https://s2.loli.net/2022/03/10/i7XqtFN4cnMP6r8.png" alt="image-20211130103643634"></p>
</li>
<li><p>获得字符串</p>
<p><code>bs.title.string</code></p>
<p>这里实际的返回值类型并不是字符串,而是其bs中的对象</p>
</li>
<li><p>注释类型</p>
<p><code>bs4.element.Comment</code></p>
<p>自动去除注释的左右封闭标签,只保留文本内容.</p>
<p>与<code>bs4.element.NavigatableString</code>的区别在于类型不同</p>
</li>
<li><p>文档的遍历</p>
<p>传送门:</p>
<p><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id18">Beautiful Soup 4.4.0 文档 — Beautiful Soup 4.2.0 中文 文档</a></p>
</li>
<li><p><strong>文档的搜索</strong></p>
<p>定位想要的内容.</p>
<p><code>find_all</code>的返回值通常是数组类型.</p>
<ul>
<li><p><code>find_all(index)</code></p>
<p>字符串过滤,会查找与字符串完全匹配的内容</p>
<p><code>bs.find_all(&quot;a&quot;)</code></p>
</li>
<li><p><code>search(正则表达式)</code></p>
<p>实际上还是使用<code>find_all(re.compile(&quot;a&quot;))</code></p>
<p>相当于符合正则匹配的内容,例如含有<code>&quot;a&quot;</code></p>
</li>
<li><p>方法搜索(传入函数,根据函数要求搜索)</p>
<p>例如查找所有含有<code>name</code>属性的内容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_is_exists</span>(<span class="params">tag</span>):</span></span><br><span class="line">	<span class="keyword">return</span> tag.has_attr(<span class="string">&quot;name&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bs.find_all(name_is_exists)</span><br></pre></td></tr></table></figure></li>
<li><p>参数搜索</p>
<p><code>kwargs</code>方法</p>
<p>相当于传入参数,寻找指定参数的所有东西.</p>
<ol>
<li><p>返回符合条件的标签及其子内容.</p>
<p><code>bs.find_all(id=&quot;head&quot;)</code></p>
</li>
<li><p>例如查找含有<code>href</code>的标签:</p>
<p><code>bs.find_all(href=True)</code></p>
</li>
<li><p>查找<code>text参数</code>(文本参数)</p>
<p><code>bs.find_all(text=&quot;hao123&quot;)</code></p>
<p>返回的是<code>list</code></p>
<p>也可以查找不止一个文本,即<code>text=[&quot;hao123&quot;,&quot;abc&quot;]</code></p>
</li>
<li><p><code>limit</code>限制查找返回的个数</p>
<p><code>bs.find_all(&quot;a&quot;,limit=6)</code></p>
<p>返回查找到的前六个<code>a</code>标签</p>
</li>
</ol>
</li>
<li><p>选择器搜索</p>
<p><code>bs.select(&#39;&#39;)</code></p>
<p>返回指<strong>仍然是列表</strong>的形式</p>
<p>也可以嵌套搜索,即查找<code>a</code>标签中的类为<code>name</code>的标签,即需要</p>
<p><code>bs.select(&quot;a[class=&#39;name&#39;]&quot;)</code></p>
<p>以及</p>
<p><code>bs.select(&quot;head &gt; title&quot;)</code> </p>
<p>相当于在树中确定根节点然后找子结点的操作</p>
<p><code>bs.select(&quot;.abc ~ .aaa&quot;)</code></p>
<p>查找与<code>abc</code>类同属兄弟节点的<code>aaa</code>类的内容.通过返回值<code>t_list[0].get_text</code>获取其中的文本信息.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用的搜索方式</p>
<p>在爬虫中主要使用的搜索方式:</p>
<ul>
<li><p><code>find_all(&quot;tag&quot;,属性=&quot;属性值&quot;)</code></p>
<p>需要注意的是,Beatuiful为了避免属性中的<code>class</code>与Python的关键字的<code>class</code>的重合,规定在使用属性中的<code>class</code>时写作<code>class_</code>,举例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;...&quot;</span></span><br><span class="line">resp=requests.get(url)</span><br><span class="line">page=BeautifulSoup(resp.text,<span class="string">&quot;html.parse&quot;</span>)</span><br><span class="line">page.find_all(<span class="string">&quot;div&quot;</span>,class_=<span class="string">&quot;title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>返回的内容是标签内包含的<strong>所有内容</strong>.</p>
</li>
<li><p><code>find_all(&quot;tag&quot;,attrs=&#123;&quot;属性&quot;:&quot;属性值&quot;,[...]&#125;)</code></p>
<p>通过这种方式,可以进一步定义到更加精确的多属性标签.</p>
</li>
<li><p><code>find_all()</code>的返回值可以继续进行嵌套使用<code>find_all()</code></p>
<p>使用过程中应当注意其对应的返回值,正常情况下返回的结果是一个列表形式.</p>
<p>通过for循环进行遍历,进一步搜索和提取.</p>
</li>
<li><p>获取到想要的属性值和内容</p>
<ol>
<li>如果想要获取到标签中的text,可以通过<code>.text</code>获取.</li>
<li>如果想要得到标签中的属性值例如<code>href</code>,通过<code>.get(&quot;href&quot;)</code>获取</li>
</ol>
</li>
<li><p>如果想要获取到兄弟标签,可以通过调用<code>element.next_sibling</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="re正则表达式"><a href="#re正则表达式" class="headerlink" title="re正则表达式"></a><code>re</code>正则表达式</h2><p>字符串模式.</p>
<p><strong>建议在正则表达式中,被比较的字符串前面加上<code>r</code>  不用担心转义字符</strong></p>
<p>常用参考<a href="https://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">传送门</a></p>
<p><img src="https://s2.loli.net/2022/03/10/lyZt8bIjNsEz9MR.png" alt="P4"></p>
<p><img src="https://s2.loli.net/2022/03/10/3vJKXiUexjHrzYO.png" alt="P5"></p>
<hr>
<p><code>Re</code>库主要功能:</p>
<p><img src="https://s2.loli.net/2022/03/10/3CiOaqBV5G1jPbd.png" alt="P6"></p>
<p><img src="https://s2.loli.net/2022/03/10/FVslWUugYHbjc1f.png" alt="P7"></p>
<p>常用功能:</p>
<p><code>re.compile(pattern)</code></p>
<p>预加载,相当于先编译一下匹配的pattern.</p>
<p>那么在后续的函数使用时,是使用该函数返回的obj进行match.</p>
<p><code>re.match()</code></p>
<p>通常只返回找到的<strong>第一个</strong>符合条件的<strong>位置</strong>,并且是从头开始匹配</p>
<ul>
<li><p>先创造匹配模式(正则表达式),再对字符串进行匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创造模式对象</span></span><br><span class="line">pat = re.<span class="built_in">compile</span>(<span class="string">&quot;AA&quot;</span>)  <span class="comment"># 这里相当于创造正则表达式  让其他东西来匹配</span></span><br><span class="line">m = pat.search(<span class="string">&quot;ADDCAA&quot;</span>)  <span class="comment"># 返回值对象,其中的span代表位置 返回找到的第一个位置</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值:&lt;re.Match object; span=(4, 6), match=&#x27;AA&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>不需要创造匹配模式,只应用于一个字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果不创建模式对象 相对简略</span></span><br><span class="line"><span class="comment"># 前面的是规则,是正则表达式</span></span><br><span class="line">m = re.search(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;AsdaaAA&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:&lt;re.Match object; span=(5, 7), match=&#x27;AA&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>re.findall()</code></p>
<p>返回<strong>所有</strong>符合条件的<strong>内容</strong>,返回形式为列表</p>
<ul>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># findall</span></span><br><span class="line"><span class="comment"># 找到所有的元素返回到列表中</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">&quot;[A-Z]&quot;</span>, <span class="string">&quot;ThisisWords&quot;</span>))  <span class="comment"># 返回所有的大写字母</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">&quot;[A-Z]+&quot;</span>, <span class="string">&quot;DOES this MatchING?&quot;</span>))  <span class="comment"># 返回所有至少有一个的大写字母簇</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>re.sub()</code></p>
<p>将给定的字符串中符合表达式的目标内容替换成给定的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sub</span></span><br><span class="line"><span class="comment"># 将前面的换成后面的</span></span><br><span class="line"><span class="built_in">print</span>(re.sub(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;What are you talking?&#x27;</span>))</span><br></pre></td></tr></table></figure>



<p><code>re.finditer(pattern,string)</code></p>
<p>返回的是一个迭代器指针,通过for循环可以一次访问指针的内容,包括匹配结果字符串<code>match</code>和位置<code>span</code></p>
<p><code>re.search(pattern,string)</code></p>
<p>返回的相当于是<code>finditer</code>函数返回的迭代器指针指向的内容,且是第一个.</p>
<p>这种东西称之为match对象,从match对象中拿数据,需要使用<code>.group()</code>方法,但返回的可能不是我们想要的,而是存在冗余信息.那么如果获取我们想要的特定内容,可以在想要获取的内容前面增加以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?P&lt;varName&gt;.*?)</span><br></pre></td></tr></table></figure>

<p>这样,匹配的内容将会被放在<code>varName</code>中,然后在使用时,可以通过<code>.group(&quot;varName&quot;)</code>进行获取.</p>
<p>例子:<img src="https://s2.loli.net/2022/03/10/cezG9nYAaFg5BCx.png" alt="image-20220224235237631" style="zoom:67%;" /></p>
<p><code>re.S</code>等状态位</p>
<p>可以在编译也就是预加载的时候进行处理,用来防止换行的出现</p>
<h2 id="XPATH"><a href="#XPATH" class="headerlink" title="XPATH"></a><code>XPATH</code></h2><p>是在XML文档中搜索内容的一门语言,相对简单,爬虫多用.</p>
<p>节点关系与树形结构类似.含有父结点,子结点,同胞节点的概念.</p>
<p>采用类文件夹路径的方式进行查找.</p>
<blockquote>
<p>pip install lxml</p>
</blockquote>
<p>进行内容获取时,通过调用其中的<code>etree</code></p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml=<span class="string">&quot;&quot;</span></span><br><span class="line">tree=etree.XML(xml[,parser,base_url])</span><br></pre></td></tr></table></figure>

<p>其中除了可以应用于<code>XML</code>之外,还可以</p>
<ul>
<li>直接指定<code>etree.HTML(text,parser,base_url)</code>解析<code>HTML</code></li>
<li>指定<code>etree.parse(source,parser,base_url)</code>解析文件</li>
</ul>
<p>层级结构:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/book/author/nick/text()&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过<code>text()</code>进行内容的提取,只完全根据路径信息进行提取,返回的是一个列表list.</p>
<p>如果想要获取某个层级下的所有的后代节点,通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果是找到<code>author</code>下的所有后代<code>nick</code>节点</p>
<p>如果想要进行层级的跳跃,例如我不关心儿子节点是什么,我只关心孙子节点,那么使用通配符<code>*</code></p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>如果我只想要获取到的若干中间节点<code>x</code>中的第n个**(从1开始计数)**,那么可以写作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/a/b/.../x[n]/...&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>如果想要获取到中间节点<code>x</code>的某个属性值<code>attr</code>为<code>value</code>的中间节点.那么可以写作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/a/b/.../x[@attr=&#x27;value&#x27;]/...&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>想要在对获得到的所有标签进行遍历时,进一步进行相关搜索,可以通过:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result=tree.xpath(<span class="string">&quot;/html/.../&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> per_line <span class="keyword">in</span> result:</span><br><span class="line">	per_line.xpath(<span class="string">&quot;./li/...&quot;</span>) <span class="comment"># 关键点就在于.</span></span><br></pre></td></tr></table></figure>



<p>获取拿到的标签的属性值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">per_line.xpath(<span class="string">&quot;./a/@href&quot;</span>) <span class="comment"># 获取到a标签中的href值</span></span><br></pre></td></tr></table></figure>



<p><strong>综合来说</strong></p>
<ul>
<li><code>/text()</code>获取内容</li>
<li><code>//</code>所有后代</li>
<li><code>/*/</code>不关心孩子节点</li>
<li><code>[n]</code>顺序的筛选</li>
<li><code>[@xxx=]</code>属性的筛选</li>
<li><code>./</code>继续进行搜索</li>
<li><code>/@xxx</code>获取对应的属性值</li>
</ul>
<p><strong>小技巧:</strong></p>
<p>可以通过抓包工具中获取一个标签的XPATH路径,然后进行微调即可获取同级的内容.</p>
<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a><code>requests</code></h2><ul>
<li><p>该库的使用中,需要注意在完成一个请求,得到返回值后,要及时关闭响应.</p>
<p>通过使用<code>responce.close()</code>关闭当前响应</p>
</li>
<li><p>常使用的函数内容包括<code>request.get(url,header,params)</code>以及<code>request.post(url,data,cookies)</code></p>
</li>
</ul>
<h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><h2 id="1-cookie处理"><a href="#1-cookie处理" class="headerlink" title="1. cookie处理"></a>1. cookie处理</h2><p>可以通过<code>session</code>进行请求.(会话)</p>
<p><code>session</code>的特点是,可以发送一连串的请求且这一连串的请求中的cookie不会丢失.</p>
<p>因此我们的步骤是:</p>
<ol>
<li>登录-&gt;得到cookie</li>
<li>带着cookie请求后续内容</li>
</ol>
<p>需要首先创建一个session对象,该对象具有<code>get</code>和<code>post</code>方法</p>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先创建一个session对象</span></span><br><span class="line">session=requests.session</span><br><span class="line">loginData=&#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">loginURL=<span class="string">&quot;...&quot;</span></span><br><span class="line">session.post(loginURL,data=loginData)</span><br><span class="line">targetURL=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 此时得到的resp就是携带了cookie得到的相应内容</span></span><br><span class="line">resp=session.post(targetURL)</span><br></pre></td></tr></table></figure>

<h2 id="2-防盗链处理"><a href="#2-防盗链处理" class="headerlink" title="2. 防盗链处理"></a>2. 防盗链处理</h2><p>这里的防盗链的处理以梨视频为例进行分析.</p>
<p>所谓的防盗链只是在请求某个页面时,header中需要存在一个项即<code>Referer</code>,也就是对面的服务器需要知道当前的请求来源,是从哪个页面发出的此请求.</p>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol>
<li><p>首先进入梨视频主页,随点点击进入一个页面,上方即视频播放页.</p>
</li>
<li><p>通过浏览器抓包工具,查看接收到的<code>XHR</code>类型的文件</p>
</li>
<li><p>可以发现接收到了<code>JSON</code>数据包,其中包含的即视频的信息.</p>
<img src="https://s2.loli.net/2022/03/18/4mlUr3Bs51DWEMz.png" alt="image-20220318131012430" style="zoom: 67%;" />

<p>通过其中的<code>srcURL</code>信息,尝试直接访问视频源,发现网页返回404错误代码.</p>
</li>
<li><p>比对网页中嵌入的视频源链接与我们通过JSON包拿到视频源链接,可以发现不同之处</p>
<img src="https://s2.loli.net/2022/03/18/ehWfpJU1N4oRXnI.png" alt="image-20220318131405875" style="zoom:80%;" />

<p>可以发现后者的视频源中,将前者的<code>164...856</code>部分的数据更换成了<code>cont-1755372</code></p>
<p>因此,只要我们尝试<strong>将两者进行转换</strong>,即可拿到视频.</p>
</li>
<li><p>对比视频原始所在的页面url,与可播放的url,可以知道,上述更换是将<strong>原始界面中的链接部分</strong>与后者相结合了.进而我们可以确定爬取思路.</p>
<p><img src="https://s2.loli.net/2022/03/18/ny2cZkhOMaJREFv.png" alt="image-20220318132008708"></p>
</li>
<li><p>爬取思路</p>
<ul>
<li><p>首先根据原url,发送请求抓取json数据包,提取出其中的<code>systemTime</code>和<code>srcUrl</code>,</p>
</li>
<li><p>将<code>srcUrl</code>部分中的<code>system</code>替换为<code>cont-原url后半部分</code>.</p>
</li>
<li><p>向得到的新URL发送请求,拿到视频数据.</p>
</li>
</ul>
</li>
<li><p>代码</p>
<p>其他相关程序:</p>
<p>通过此程序,返回请求时的文件头,<code>Get</code>选项决定是否添加<code>Referer</code>项内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time      : 2022/3/18 10:00</span></span><br><span class="line"><span class="comment"># @Author    : Baxkiller</span></span><br><span class="line"><span class="comment"># @File      : userAgent.py</span></span><br><span class="line"><span class="comment"># @Software  : PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetHeaders</span>(<span class="params">URL = <span class="string">&quot;&quot;</span>, Get = <span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Get:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headers</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: URL</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headers</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主爬虫程序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time      : 2022/3/18 12:51</span></span><br><span class="line"><span class="comment"># @Author    : Baxkiller</span></span><br><span class="line"><span class="comment"># @File      : LiVideo.py</span></span><br><span class="line"><span class="comment"># @Software  : PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> userAgent <span class="keyword">import</span> GetHeaders</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梨视频的视频爬取</span></span><br><span class="line"><span class="comment"># 获取用户给定的视频链接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_InitURL</span>():</span></span><br><span class="line">    initURL = <span class="built_in">input</span>(<span class="string">&quot;请输入想要下载的梨视频页面地址&quot;</span>)</span><br><span class="line">    backDigit = <span class="built_in">eval</span>(initURL.split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> [initURL, backDigit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取含有视频源的json字典文件,同时解析视频名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getJson</span>(<span class="params">videoID, initUrl</span>):</span></span><br><span class="line">    url = <span class="string">f&quot;https://www.pearvideo.com/videoStatus.jsp&quot;</span></span><br><span class="line">    pars = &#123;</span><br><span class="line">        <span class="string">&quot;contId&quot;</span>: videoID,</span><br><span class="line">        <span class="string">&quot;mrd&quot;</span>: <span class="string">&quot;0.5174454474260293&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取视频的名称</span></span><br><span class="line">    name_resp = requests.get(url = initUrl, headers = GetHeaders(Get = <span class="literal">False</span>))</span><br><span class="line">    tree = etree.HTML(name_resp.text)</span><br><span class="line">    name = tree.xpath(<span class="string">&quot;.//h1[@class=&#x27;video-tt&#x27;]/text()&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error:Can&#x27;t get the name of the Video&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The Video Name is :&quot;</span>, name)</span><br><span class="line">        <span class="comment"># 防止封锁IP</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取JSON内容</span></span><br><span class="line">    resp = requests.get(url = url, headers = GetHeaders(initUrl), params = pars)</span><br><span class="line">    json = resp.json()</span><br><span class="line">    json[<span class="string">&#x27;name&#x27;</span>]=name</span><br><span class="line">    <span class="keyword">return</span> json</span><br><span class="line">    <span class="comment"># 拿到通过json抓取到的视频源地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对拿到的json进行处理,拿到视频源</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_systime_SrcUrl</span>(<span class="params">json</span>):</span></span><br><span class="line">    systemTime = json[<span class="string">&#x27;systemTime&#x27;</span>]</span><br><span class="line">    srcUrl = json[<span class="string">&#x27;videoInfo&#x27;</span>][<span class="string">&#x27;videos&#x27;</span>][<span class="string">&#x27;srcUrl&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> [systemTime, srcUrl]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取视频内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askVideo</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将视频内容进行保存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SaveVideo</span>(<span class="params">Video, path</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(path, mode = <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        lt = <span class="built_in">list</span>(<span class="string">&#x27;\\/:*?&quot;&lt;&gt;|&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> lt:</span><br><span class="line">            path=path.replace(c,<span class="string">&quot;_&quot;</span>)</span><br><span class="line">        f=<span class="built_in">open</span>(path,mode = <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    f.write(Video)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    [url, subDigit] = Get_InitURL()</span><br><span class="line">    json= getJson(subDigit, url)</span><br><span class="line">    systime, videoSrc = get_systime_SrcUrl(json)</span><br><span class="line">    url = videoSrc.replace(systime, <span class="string">f&quot;cont-<span class="subst">&#123;subDigit&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Asking the URL ... &quot;</span>)</span><br><span class="line">    VideoContent = askVideo(url)</span><br><span class="line">    SaveVideo(VideoContent, <span class="string">f&quot;<span class="subst">&#123;json[<span class="string">&#x27;name&#x27;</span>]&#125;</span>.mp4&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Video Save Finished!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-代理-IP"><a href="#3-代理-IP" class="headerlink" title="3. 代理(IP)"></a>3. 代理(IP)</h2><p>通过第三方的服务器去发送请求.</p>
<p>如果对于某个网站的请求发送非常频繁,为了防止IP被封锁,或者说为了解决被封锁掉的IP,可以通过代理进行访问.</p>
<blockquote>
<p>一般来说,匿名度为透明的速度较快,而匿名度为高匿的比较慢.</p>
<p>代理的使用只需要在request的方法中添加参数<code>proxies</code>.</p>
<p>而<code>proxies</code>本身的定义和赋值要区分<code>http</code>和<code>https</code>.</p>
</blockquote>
<p>举例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;https://218.60.8.83:3129&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">resp = requests.get(url = url, proxies = proxies)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure>

<p>应当注意其中的第四行的两个<code>https</code>与第7行的<code>https</code>应该是对应的.</p>
<p>也就是<code>https</code>vs<code>https</code></p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="web请求解析全过程"><a href="#web请求解析全过程" class="headerlink" title="web请求解析全过程"></a>web请求解析全过程</h2><ol>
<li><p>服务器渲染</p>
<p>在服务器方将数据与html整合,统一返回给浏览器.</p>
</li>
<li><p>客户端渲染(浏览器方)</p>
<p>如果显示时含有某些内容,而在html的源代码中并没有直接出现该内容,属于客户端渲染.</p>
<img src="https://s2.loli.net/2022/03/10/JeRzP5SoWs4d7BU.png" alt="image-20220207171859471" style="zoom:67%;" />

<p>在浏览器方,将html骨架与数据结合在一起.</p>
<p>第一次请求只需要一个html股价,然后其中包含脚本,再次向服务器段请求数据.</p>
<p>第二次的请求可以得到数据,然后将数据与脚本结合,展示出来.</p>
<p>以豆瓣电影中的喜剧片排行榜为例:</p>
<blockquote>
<p>第一次请求得到的html框架如下所示:</p>
<img src="https://s2.loli.net/2022/03/10/NadUqcO2Ab1SBWX.png" alt="image-20220207173033659" style="zoom: 80%;" />



<p>第二次请求得到的数据,通过json文件的形式返回:</p>
<img src="https://s2.loli.net/2022/03/10/tAPp1yfzrwFQZ6c.png" alt="image-20220207173157863" style="zoom:67%;" />
</blockquote>
<p>第一次请求得到的骨架并不是我们所期望得到的.    </p>
</li>
</ol>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>全称超文本传输协议. </p>
<p>http协议的请求和响应都是分为三大块.</p>
<p>请求:</p>
<blockquote>
<p>请求行-&gt; 请求方式,请求url地址,协议.</p>
<p>请求头-&gt; 放一些服务器要使用的附加信息</p>
<p>请求体-&gt; 放一些请求参数.</p>
</blockquote>
<p>响应:</p>
<blockquote>
<p>状态行-&gt; 协议,状态码</p>
<p>响应头-&gt; 放一些客户端要使用的一些附加信息.(密钥/cookie)</p>
<p>响应体-&gt; 服务器返回的真正客户端要用的内容.(HTML,JSON等)</p>
</blockquote>
<p>请求头中常见的重要内容:</p>
<ol>
<li>user-agent:请求载体的身份信息.</li>
<li>referer: 防盗链(这次请求是从哪个页面来的.用于反爬虫).</li>
<li>cookie:本地字符串数据信息(用户登录信息,反爬的token)</li>
</ol>
<p>响应头中的重要信息:</p>
<ol>
<li>cookie: 本地字符串数据信息(用户登录信息,反爬虫的token)</li>
<li>各种莫名其妙的字符串(一般都是token字样,防止各种攻击和反爬)</li>
</ol>
<p>请求方式:</p>
<ul>
<li><p>get:显示提交</p>
<p>例如查询.地址栏的内容变动获取到的东西不同,统一属于<code>GET</code>方式提交.</p>
<p>关键点在于,获取内容时传递的参数是通过url进行传递的.比如这里的<code>query=</code></p>
<p><strong>小妙招:通过f’<a href="https://www.sougou.com/query=%7Bquery%7D&#39;%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92,%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC">https://www.sougou.com/query={query}&#39;可以进行参数的传递,也就是在字符串中使用变量的值</a></strong></p>
<blockquote>
<p>给定一个地址url,通过get方式发送请求request.</p>
<p>这里使用到了request库中的get(url),返回值是响应responce</p>
<p>可以通过responce.text获取到网页的源代码.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line"> url = <span class="string">&#x27;https://www.sogou.com/web?query=周杰伦&#x27;</span></span><br><span class="line"> headers = &#123;</span><br><span class="line">     <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> resp = requests.get(url, headers = headers)</span><br><span class="line"> <span class="built_in">print</span>(resp) <span class="comment"># 返回的是状态码</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line"> <span class="built_in">print</span>(resp.text) <span class="comment"># 查看的是网页得源代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"> test()</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Finished!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>post:隐示提交</p>
<p>请求提交时,发送的数据是通过表单中的数据进行传递的.</p>
<p>对于POST类型的参数传递,通过<code>requset.post(url=,data=)</code></p>
<p>返回结果通过<code>responce.json()</code>可以直接得到.</p>
<p>想要获得什么数据,就去浏览器抓包工具中找到想要获得的数据.然后查看该数据的标头,得到<strong>请求url和请求方法</strong>,然后通过爬虫进行爬取.</p>
<blockquote>
<p>百度翻译中的单个单词翻译为例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post内容发送时,一定要放在字典中进行参数的传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translateBaidu</span>(<span class="params">content</span>):</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(content) &lt;= <span class="number">1</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;请重新输入翻译内容:&quot;</span>)</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"> url = <span class="string">&#x27;https://fanyi.baidu.com/sug&#x27;</span></span><br><span class="line"> dat = &#123;</span><br><span class="line">     <span class="string">&quot;kw&quot;</span>: content</span><br><span class="line"> &#125;</span><br><span class="line"> header = &#123;</span><br><span class="line">     <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> reps = requests.post(url = url, data = dat)</span><br><span class="line"> <span class="built_in">print</span>(reps.json()) <span class="comment"># 返回的内容直接处理成json</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>两者的区分</p>
<p>两种方式的区分可以通过浏览器的<code>F12</code>窗口的抓包工具进行区分.</p>
<p>这里举例:</p>
<blockquote>
<p>以百度翻译为例.</p>
<p>当输入一个英文单词时,查看F12中的网络选项,在输入之前通过下图按钮清楚请求得到的响应内容.</p>
<p><img src="https://s2.loli.net/2022/03/10/VTdyMHgpAvmqYax.png" alt="image-20220220145923300"></p>
<p>然后输入,输入完成后查看网络中得到的数据.</p>
<p>这里以输入单词后的单词翻译和提示来讲,可以找到<strong>xhr</strong>类型的返回值,确定是我们要找的单词的翻译.</p>
<img src="https://s2.loli.net/2022/03/10/Jj57iXTzoNxOCuE.png" alt="image-20220220150116312" style="zoom:80%;" />

<p>点击内容,查看预览.与目标内容相符</p>
<p><img src="https://s2.loli.net/2022/03/10/KpXFahPdB6Y85zi.png" alt="image-20220220150217352"></p>
<p>点击标头,查看发送请求的url.</p>
<p><img src="https://s2.loli.net/2022/03/10/nWeCDhvsO7y6laT.png" alt="image-20220220151045559"></p>
<p>可以发现URL中并没有我们请求的参数.并且在请求方法中已经明确了是<code>POST</code>.接下来去<code>Payload</code>或者标头页面的最底下找到参数传递:</p>
<p><img src="https://s2.loli.net/2022/03/10/XoywHAQlJmfSu4e.png" alt="image-20220220151228517"></p>
<p>注意字典格式.根据这个格式进行数据传递.</p>
<p>返回值如果要打印,可以直接使用<code>resp.json()</code>打印获得的<strong>xhr</strong>类型数据</p>
</blockquote>
</li>
</ul>
<h1 id="实战举例"><a href="#实战举例" class="headerlink" title="实战举例"></a>实战举例</h1><h2 id="爬取豆瓣某分类的榜单"><a href="#爬取豆瓣某分类的榜单" class="headerlink" title="爬取豆瓣某分类的榜单"></a>爬取豆瓣某分类的榜单</h2><ol>
<li><p>首先从抓包工具中查找是否具有相关的内容,确定渲染类型.</p>
<p>根据下图可以发现,该榜单内容属于浏览器端渲染.因此可以直接截取到相关的json文件.</p>
<p><img src="https://s2.loli.net/2022/03/10/HNyuDgl7pLnx9Fd.png" alt="image-20220220192119486"></p>
</li>
<li><p>其次,根据上图,查看对应文件的标头,得知请求方法.根据下图来看,可以知道是<code>GET</code>类型.因此可以直接通过向对应链接使用<code>request.get(url=url,headers=headers)</code></p>
<p><img src="https://s2.loli.net/2022/03/10/fSqQzMl8owvZjxK.png" alt="image-20220220192431545"></p>
</li>
<li><p>查看是否存在参数的传递</p>
<p>查看对应的<code>Payload</code>,可以发现这里存在着参数传递.</p>
<img src="https://s2.loli.net/2022/03/10/nxCaPiuFUrzoWys.png" alt="image-20220220192711638" style="zoom:80%;" /></li>
<li><p>综合</p>
<p>综上来看,确定要获取内容形式如下:</p>
<p>以<code>https://movie.douban.com/j/chart/top_list</code>作为基础链接,问号后的内容实际上是参数的传递.因此可以确定我们要使用的函数为:</p>
<p><code>request.get(url=baseurl,param=para,headers=headers)</code></p>
<p>其中的para以及headers为参数<strong>字典</strong>.</p>
<p>以上图为例,其参数字典如下:</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">para = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval_id&quot;</span>: <span class="string">&quot;100:90&quot;</span>,</span><br><span class="line">    <span class="string">&quot;action&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;limit&quot;</span>: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>结果</p>
<p>发送请求后得到的结果,通过<code>resp.json()</code>直接提取返回的内容值.提取到的是字典类型的数据<code>dict</code>.</p>
<p>这里将请求结果存储在文件中,但是在存储之前要注意将原本的返回结果中的单引号<code>&#39;</code>更换为json文件常使用的双引号<code>&quot;</code></p>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetRank</span>():</span></span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/j/chart/top_list&quot;</span>  <span class="comment"># 原url链接问号后的内容为参数</span></span><br><span class="line">    para = &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line">        <span class="string">&quot;interval_id&quot;</span>: <span class="string">&quot;100:90&quot;</span>,</span><br><span class="line">        <span class="string">&quot;action&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;limit&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.56&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 通过url与para的结合  可以生成我们想要的url</span></span><br><span class="line">    resp = requests.get(url = url, params = para, headers = headers)</span><br><span class="line">    resp.close()</span><br><span class="line">    <span class="keyword">return</span> resp.json()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    fhandle = <span class="built_in">open</span>(<span class="string">&quot;rangeOfPlot.json&quot;</span>, mode = <span class="string">&quot;w&quot;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    res = Douban.GetRank()</span><br><span class="line">    strRes = <span class="built_in">str</span>(res)</span><br><span class="line">    strRes = strRes.replace(__old = <span class="string">&#x27;\&#x27;&#x27;</span>, __new = <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">    fhandle.write(<span class="built_in">str</span>(res))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished!&quot;</span>) </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h1><p>适用条件:对于服务器渲染方式的网页,通过数据解析直接获取到网页的数据内容.</p>
<p>这里介绍三种方 式:<strong>RE(正则表达式),BS4(BeautifulSoup) ,XPATH(应用范围最广)</strong></p>
<ul>
<li><p>RE</p>
<p>详情可以查看上面提到的”re正则表达式”模块的介绍.</p>
<p>测试正则表达式的在线网站工具:<a href="https://tool.oschina.net/regex">在线正则表达式测试</a></p>
<p>(虽然之前已经给出了匹配符号的规则等等,这里还是再给一遍)</p>
<ul>
<li><p>常用元字符(具有固定含义的特殊符号)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.		匹配除换行符以外的任意字符</span><br><span class="line">\w		匹配字母数字下划线</span><br><span class="line">\s		匹配任意的空白符(例如换行,空格)</span><br><span class="line">\d		匹配数字</span><br><span class="line">\n		匹配一个换行符</span><br><span class="line">\t		匹配一个制表符</span><br><span class="line"></span><br><span class="line">^		匹配字符串的开始</span><br><span class="line">$		匹配字符串的结尾</span><br><span class="line">\W		匹配非字母数字下划线</span><br><span class="line">\D		匹配非数字</span><br><span class="line">\S		匹配非空白字符</span><br><span class="line"></span><br><span class="line">a|b		匹配a或b</span><br><span class="line">()		匹配括号内的表达式,也表示一个组</span><br><span class="line">[...]	匹配字符组中的字符</span><br><span class="line">[^...]	匹配非字符组中的字符</span><br></pre></td></tr></table></figure></li>
<li><p>量词:控制前面的元字符出现的次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*		重复0次或者无数次</span><br><span class="line">+		重复1次或者无数次</span><br><span class="line">?		重复0次或者1次</span><br><span class="line">&#123;n&#125;		重复n次</span><br><span class="line">&#123;n,&#125;	重复n次或者更多次</span><br><span class="line">&#123;n,m&#125;	重复n到m次</span><br></pre></td></tr></table></figure></li>
<li><p>贪婪匹配和惰性匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.*		贪婪匹配</span><br><span class="line">.*?		惰性匹配</span><br></pre></td></tr></table></figure>

<p>其中爬虫中常用的是**惰性匹配.**意义为:令前面这个<code>*</code>少一点,尽可能让这个<code>*</code>匹配到少一点东西.</p>
<p>原理在于,首先进行贪婪匹配,找到最远的符合条件的尾部,然后再从尾部向前找到尾部最后一次出现的结果.</p>
<p>举例:</p>
<blockquote>
<p>原字符串:<code>玩儿吃鸡游戏,晚上一起玩游戏.干啥呢?打游戏啊</code></p>
<p>符合正则表达式:<code>玩儿.*游戏</code>的字符串包括:</p>
<ol>
<li>玩儿吃鸡游戏</li>
<li>玩儿吃鸡游戏,晚上一起玩游戏</li>
<li>玩儿吃鸡游戏,晚上一起玩游戏.干啥呢?打游戏</li>
</ol>
<p>通过<code>玩儿.*?游戏</code>,那么匹配的结果为1.</p>
<p>如果<code>玩儿.*游戏</code>,那么匹配结果为3.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><ul>
<li><p>对于编码问题</p>
<p>encode指代的是将普通字符串转化为机器可识别的bytes</p>
<p>decode指代的是将bytes转化成字符串</p>
<p>因此对于Python3来说,str类型的数据不存在decode方法,只能进行encode.</p>
<p>如果在爬取网站时,网站的内容编码方式不是常见的<code>utf-8</code>,而是其他编码方式,例如<code>gbk</code>或者<code>gb2312</code></p>
<ul>
<li><p>对于<code>requests</code>库,通过发送请求后的返回值设定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp=requests.get(url=url)</span><br><span class="line">resp.encoding=<span class="string">&#x27;gbk&#x27;</span> <span class="comment"># 或resp.encoding=&#x27;gb2312&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于<code>urllib</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp=urllib.request.urlopen(request)</span><br><span class="line">html=resp.read().decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>针对网站的防火墙问题</p>
<p><strong>报错</strong>:<code>Max retries exceeded with url:(Caused by SSLError(&quot;bad handshake:Error([(&#39;SSL routines&#39;,&#39;tls_process_server_certificate&#39;,&#39;certificate verify failed&#39;)])&quot;))</code></p>
<p>通过增加参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp=requests.get(url=url,verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>数据保存</p>
<p>对于通过<code>requests</code>库获取到的内容,如果要以二进制的形式进行保存(例如我们需要对下载到的图片进行保存)</p>
<p>通过获取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resp=requests.get(url)</span><br><span class="line">resp.content   <span class="comment">##这就是我们要获得到的二进制文件</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>SELF_LEARNING</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算作业</title>
    <url>/2022/03/10/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>Description:</p>
<p>这篇博客用来存访云计算课程中的作业以供老师检查.</p>
</blockquote>
<h1 id="云计算作业一"><a href="#云计算作业一" class="headerlink" title="云计算作业一"></a>云计算作业一</h1><h2 id="1-1-云使能技术包括哪些技术组件-用一句话简要说明其关键特征"><a href="#1-1-云使能技术包括哪些技术组件-用一句话简要说明其关键特征" class="headerlink" title="1-1 云使能技术包括哪些技术组件?用一句话简要说明其关键特征"></a>1-1 云使能技术包括哪些技术组件?用一句话简要说明其关键特征</h2><ul>
<li><p>技术组件</p>
<ul>
<li><p>宽带网络和Internet架构</p>
<blockquote>
<p>使用网络路由器和交互机的无连接分组交换与基于路由器的互联来进行Internet通信</p>
</blockquote>
</li>
<li><p>数据中心技术</p>
<blockquote>
<p>存储系统技术包括磁盘阵列和存储虚拟化</p>
<p>增加存储容量的技术组件包括DAS(直接连接存储）、SAN（存储区域网络）、和 NAS（网络连接存储）</p>
</blockquote>
</li>
<li><p>虚拟化技术</p>
<blockquote>
<p>通过采用基于操作系统的虚拟化或者基于硬件的虚拟化来实现提供硬件无关性、资源复制、服务器整合的支持以及更加灵活的扩展性。</p>
</blockquote>
</li>
<li><p>Web技术</p>
<blockquote>
<p>Web浏览器客户端和Web服务器为基本组件，通过Web浏览器来显示Web应用的用户界面</p>
</blockquote>
</li>
<li><p>多租户技术</p>
<blockquote>
<p>即多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共用相同的系统或程序组件，并且仍可确保各用户间数据的隔离性。</p>
</blockquote>
</li>
<li><p>服务技术</p>
</li>
</ul>
</li>
<li><p>云使能技术的关键特征</p>
<p>所有的云必须连接到网络，同时利用数据中心技术集中存放IT资源，应用虚拟化技术将物理IT资源转换为虚拟IT资源，从而提供了硬件无关性、服务器整合、资源复制、对资源更强的支持和可扩展性；使用Web技术作为云服务的实现介值和管理接口；设计多租户技术使多个用户在逻辑上同时访问一个应用；其中的服务技术是云计算的基石，形成了“作为服务”的云交付模型的基础。</p>
</li>
</ul>
<h2 id="1-2-列举至少3种虚拟化软件-并用一句话概括其特点"><a href="#1-2-列举至少3种虚拟化软件-并用一句话概括其特点" class="headerlink" title="1-2 列举至少3种虚拟化软件,并用一句话概括其特点"></a>1-2 列举至少3种虚拟化软件,并用一句话概括其特点</h2><ul>
<li><p>VMware系列</p>
<p> VMware workstation(适合单台计算机使用)、VMware vsphere(VMware esxi)、VMware Fusion(Mac)</p>
</li>
<li><p>OpenVZ</p>
<p> 开源 基于linux 虚拟机和宿主机共用一个内核</p>
</li>
<li><p>VirtualBox </p>
<p>开源</p>
</li>
<li><p>Hyper-V</p>
<p>只支持Microsoft自家的系统，属于服务器级的.</p>
</li>
<li><p>概括特点</p>
<p>把一台物理计算机虚拟成多台逻辑计算机，每个逻辑计算机里面可以运行不同的操作系统，相互不受影响，实现对于硬件资源的充分利用</p>
</li>
</ul>
<h1 id="云计算作业二"><a href="#云计算作业二" class="headerlink" title="云计算作业二"></a>云计算作业二</h1><h2 id="2-1-列举威胁作用者有哪些-并简要说明"><a href="#2-1-列举威胁作用者有哪些-并简要说明" class="headerlink" title="2-1 列举威胁作用者有哪些,并简要说明"></a>2-1 列举威胁作用者有哪些,并简要说明</h2><ul>
<li><p>威胁作用者概念</p>
<p>威胁作用者是引发威胁的实体，因为与它能够实施攻击。云安全威胁可能来自内部也可以来自外部，可能来自于软件程序。相对于漏洞、威胁和风险以及安全策略和安全机制建立起来的保护措施而言，威胁作用者所承担的角色，如下图所示:</p>
<img src="https://s2.loli.net/2022/03/18/cZDE8bOqmXUFCGw.png" alt="20200924222622732" style="zoom:50%;" /></li>
</ul>
<ol>
<li><p>匿名攻击者</p>
<p>匿名攻击者是云中没有权限、不被信任的<strong>云服务用户</strong>，它通常是一个<strong>外部软件程序</strong>，通过公网发动网络攻击。当匿名攻击者对安全策略和防护所致有限时，这会抑制它们形成有效攻击的能力。因此，匿名攻击者往往诉诸<strong>绕过账号</strong>或<strong>窃取用户证书</strong>的手段，同时使用能够<strong>确保匿名性</strong>或<strong>需要大量资源才能被检举</strong>的方法。</p>
</li>
<li><p>恶意服务作用者</p>
<p>恶意服务作用者能截取并转发云内的网络流量。它通常是带有被损害的或恶意逻辑的<strong>服务代理</strong>或<strong>伪装成服务代理的程序</strong>，也有可能是能够<strong>远程截取并破坏消息内容的外部程序</strong>。</p>
</li>
<li><p>授信的攻击者(恶意租户)<br>授信的攻击者与同一云环境中的<strong>云用户共享IT资源</strong>，是被授权过的，试图利用合法的证书来把<strong>云提供者以及它们共享IT资源的云租户作为攻击目标</strong>。不同于匿名攻击者（它们是非授权的），授信的攻击者通常<strong>滥用合法的证书</strong>或通过<strong>挪用敏感和保密的信息</strong>，在云的<strong>信任边界内部</strong>发动攻击。</p>
<p>恶意租户能够使用基于云的IT资源做很多非法之用，包括非法入侵认证薄弱的进程、破解加密、往电子邮件账号发送垃圾邮件、发起拒绝服务等常见的攻击等.</p>
</li>
<li><p>恶意的内部人员<br>恶意的内部人员是<strong>人为的威胁作用者</strong>，它们的行为代表云提供者或者与之有关。它们通常是现任或前任雇员，或是能够访问云提供者资源范围的第三方。这种类型的威胁作用者会带来极大的破坏可能性，因为恶意的内部人员可能拥有访问云用户IT资源的管理特权。</p>
</li>
</ol>
<h2 id="2-2-列举云安全威胁有哪些-并简要说明"><a href="#2-2-列举云安全威胁有哪些-并简要说明" class="headerlink" title="2-2 列举云安全威胁有哪些,并简要说明"></a>2-2 列举云安全威胁有哪些,并简要说明</h2><ol>
<li><p>流量窃听</p>
<p>流量窃听是指当数据在传输到云中或在云内部传输时（通常是从云用户到云提供者）被恶意的服务作用者被动地截获，用于非法的信息收集之目的，这种攻击的目的就是直接破坏数据的保密性，可能也破坏了云用户和云提供者之间关系的保密性。由于这种攻击被动的本质，这种攻击更容易长时间进行而不被发现，如下图所示：</p>
<img src="https://s2.loli.net/2022/03/18/xKBUAY6Nn8XQq53.png" alt="20200925104536744" style="zoom:50%;" /></li>
<li><p>恶意媒介</p>
<p>恶意媒介威胁是指消息被恶意服务作用者截获并且被篡改，因此可能会被破坏消息的保密性和完整性。它还有可能在把消息转发到目的地之前插入有害的数据。下图说明了一个常见的恶意媒介攻击的例子：</p>
<img src="https://s2.loli.net/2022/03/18/SZGc24QYUOsveXI.png" alt="20200925110803198" style="zoom:50%;" /></li>
<li><p>拒绝服务</p>
<p>拒绝服务（Dos）攻击的目标是使IT资源过载至无法正确运行。这种形式的攻击通过是以以下方式之一发起的：</p>
<p>1）云服务上的负载由于伪造的消息或重复的通信请求不正常地增加。</p>
<p>2）网络流量过载，降低了响应性，性能下降。</p>
<p>3）发出多个云服务请求，每个请求都设计成消耗过量的内存和处理资源。</p>
<p>成功的DOS攻击使得服务器性能恶化或失效，如下图所示：</p>
<img src="https://s2.loli.net/2022/03/18/hUZsqrowJBIcYtW.png" alt="20200925160403421" style="zoom: 50%;" />

<p>如上图所示，云服务用户A向位于虚拟服务器A上的云服务发送多个消息，这超过了底层物理服务器的容量，导致虚拟服务器A和B中断服务。结果，合法的云服务用户（如云服务用户B）无法与任何位于虚拟服务器A和B上的云服务通信。</p>
</li>
<li><p>授权不足</p>
<p>授权不足攻击是指错误地授予攻击者访问权限或是授权太宽泛，导致攻击者能够访问到本应该受到保护的IT资源。通常结果就是攻击者获得了对某些IT资源的直接访问的权利，这些资源实现的时候是假设只能是授信的用户程序才能访问的。这种攻击的一种变种称为弱认证，如果用弱密码或共享来保持IT资源就可能导致这种攻击。在云环境内，根据IT资源的范围和攻击者获得的对IT资源的访问权限范围，这类型的攻击可能会产生严重的后果。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CLASS</tag>
      </tags>
  </entry>
  <entry>
    <title>WebCrawler_music163_comments</title>
    <url>/2022/03/19/WebCrawler-music163-comments/</url>
    <content><![CDATA[<h1 id="网易云音乐评论爬取"><a href="#网易云音乐评论爬取" class="headerlink" title="网易云音乐评论爬取"></a>网易云音乐评论爬取</h1><h2 id="确定信息来源"><a href="#确定信息来源" class="headerlink" title="确定信息来源"></a>确定信息来源</h2><p>查看网页中任意一首音乐的评论来源:网页本身/数据包</p>
<p>通过浏览器工具,可以确定数据来源于网络传输的数据包.</p>
<img src="https://s2.loli.net/2022/03/19/MpONxdQut13jwBT.png" alt="image-20220319104619073" style="zoom: 67%;" />

<h2 id="尝试进行抓取"><a href="#尝试进行抓取" class="headerlink" title="尝试进行抓取"></a>尝试进行抓取</h2><ul>
<li><p>首先查看该数据包对应的标头中请求的URL以及请求方式.</p>
<p><code>POST</code>请求,给定了URL.</p>
</li>
<li><p>内容负载</p>
<p>其内容负载包含两个方面:</p>
<img src="https://s2.loli.net/2022/03/19/srJWAhgoONfTUPC.png" style="zoom: 80%;" >

<p>很明显,这个内容负载是经过了加密.因此为了将我们的数据进行同样的加密以获取评论内容,我们要知道<strong>被加密内容</strong>是什么以及<strong>怎样加密</strong>的.</p>
</li>
<li><p>获取加密方式</p>
<p>查看浏览器工具中的<code>Network-&gt;Initator</code>,其中包含有<code>Request call stack</code></p>
<p>在Edge的调试工具中两者命名分别是<code>发起程序</code>和<code>请求调用堆栈</code>.</p>
<p>记录当发送请求到我们想要的URL时,经历过了哪些<strong>JS脚本的执行过程</strong>,由于是堆栈,因此<strong>越靠下的部分越先被调用</strong>.</p>
<p>查看最后被调用的代码.由于代码比较凌乱,因此我们点击其左下角的大括号,可以看到比较规矩的代码.</p>
<p>通过在代码处设置断点,并再次运行整个网页对函数运行进行拦截,可以看到每一次调用该函数时所设置/用到的相关变量.通过查看拦截后的右侧<code>Local</code>内容,查看每次调用时发送请求时的url,与我们之前确定好的url对比,如果相同,则查看相关变量,看是否有我们想要的变量.如果该变量被加密,则继续通过调用堆栈中的函数回溯找,直到找到加密前的我们想要的变量.</p>
</li>
<li><p>以福禄寿歌曲《我用什么把你留住》为例</p>
<p>首先通过抓包工具截取到歌曲的评论数据包请求的url地址为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后找到堆栈调用的位置,在函数出口处打断点,然后重新加载请求网页.每次查看被中断的请求的请求地址是否与上面的地址相同.</p>
<p>经过大概四次/五次的中断,找到目的请求:</p>
<p><img src="https://s2.loli.net/2022/03/19/UApKREgwJmv4eH3.png" alt="image-20220319145543440"></p>
<p>经过查看不难发现此时的参数仍然是被加密后的,因此我们去找堆栈中调用该层函数的函数,也就是其父结点,继续进行如上操作,直到找到未被加密的程序.如下图所示,为了后续使用方便,我们将该数据下面的i4m数据,也就是加密前的字典类型的<strong>数据暂存</strong>.</p>
<img src="https://s2.loli.net/2022/03/19/xO2kEsLQCt1ioye.png" alt="image-20220319151721202" style="zoom:80%;" />



<p>由此可以确定,加密应该是在函数<code>tax.be4i</code>函数中完成的.因此我们转去查看``tax.be4i`函数中的加密过程.</p>
<p>通过查看函数内部的代码,可以发现下图中,下方的红框内的数据是待加密的数据,而上方的红框内为加密完成后的数据.</p>
<img src="https://s2.loli.net/2022/03/19/KuLBJU8OzQTAjhE.png" alt="image-20220319152316123" style="zoom:80%;" />



<p>在函数内部中对内容<code>e4i</code>赋值的相关位置打断点,重新加载页面,确定内容加密的具体位置.</p>
<img src="https://s2.loli.net/2022/03/19/8PlZyW95wFQ4mbi.png" alt="image-20220319152500291" style="zoom:80%;" />



<p>可以发现在断点1处的数据仍然未被加密.</p>
<p><img src="https://s2.loli.net/2022/03/19/TthqENBrRljgDzF.png" alt="image-20220319154125733"></p>
<p>到断点3,可以发现数据已经被加密</p>
<img src="https://s2.loli.net/2022/03/19/VyawYSsiqdjP8et.png" alt="image-20220319155734133" style="zoom: 80%;" />



<p>到断点4,发现数据已经完全被加密完成:</p>
<img src="https://s2.loli.net/2022/03/19/xP4OZwSanQ2zFth.png" alt="image-20220319155849279" style="zoom:80%;" />



<p>那么通过查看上面的断点3处的代码,可以发现,在断点3处为数据进行了赋值,成员包括<code>encSevKey</code>和<code>params</code>,两者正是我们要找到的参数,并且两者都来自于变量<code>bVj8b</code>.而变量<code>bVj8b</code>的数据又是通过函数<code>Windows.asrsea</code>产生的.因此我们在整个页面中查找该函数.</p>
<p>找到该函数的赋值位置,然后进一步确定该函数的内部参数的含义:</p>
<p><img src="https://s2.loli.net/2022/03/19/YorSHM45tpGUzdb.png" alt="image-20220319160516620"></p>
<p>解析如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数通过调用此处的函数产生</span></span><br><span class="line"><span class="keyword">var</span> bVj8b = <span class="built_in">window</span>.asrsea(<span class="built_in">JSON</span>.stringify(i4m), bsR5W([<span class="string">&quot;流泪&quot;</span>, <span class="string">&quot;强&quot;</span>]), bsR5W(Xp0x.md), bsR5W([<span class="string">&quot;爱心&quot;</span>, <span class="string">&quot;女孩&quot;</span>, <span class="string">&quot;惊恐&quot;</span>, <span class="string">&quot;大笑&quot;</span>]));</span><br><span class="line">e4i.data = j4n.cq4u(&#123;</span><br><span class="line">    <span class="attr">params</span>: bVj8b.encText,  <span class="comment">// 负载参数之一</span></span><br><span class="line">    <span class="attr">encSecKey</span>: bVj8b.encSecKey  <span class="comment">// 负载参数之二</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// asrsea函数外部</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;  <span class="comment">// 进行a次循环,每次循环产生一个字符,共产生a个字符.</span></span><br><span class="line">        <span class="keyword">var</span> d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (d = <span class="number">0</span>; a &gt; d; d += <span class="number">1</span>)</span><br><span class="line">            e = <span class="built_in">Math</span>.random() * b.length,</span><br><span class="line">            e = <span class="built_in">Math</span>.floor(e),</span><br><span class="line">            c += b.charAt(e);</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 也就是加密函数,以b为密钥,对a进行加密</span></span><br><span class="line">        <span class="keyword">var</span> c = CryptoJS.enc.Utf8.parse(b)  <span class="comment">// 密匙编码</span></span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(<span class="string">&quot;0102030405060708&quot;</span>) <span class="comment">// 偏移量编码</span></span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)  <span class="comment">// 编码转换</span></span><br><span class="line">          <span class="comment">// AES 加密</span></span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;</span><br><span class="line">            <span class="attr">iv</span>: d,                          <span class="comment">// 偏移量</span></span><br><span class="line">            <span class="attr">mode</span>: CryptoJS.mode.CBC         <span class="comment">// 加密模式</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> f.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数为随机字符串i,固定值e(?)和固定值f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">a, b, c</span>) </span>&#123;                   <span class="comment">// encSecKey的生成函数</span></span><br><span class="line">        <span class="keyword">var</span> d, e;</span><br><span class="line">        <span class="keyword">return</span> setMaxDigits(<span class="number">131</span>),</span><br><span class="line">        d = <span class="keyword">new</span> RSAKeyPair(b,<span class="string">&quot;&quot;</span>,c),         <span class="comment">// 对不同歌曲的固定值e进行加密</span></span><br><span class="line">        e = encryptedString(d, a)           <span class="comment">// 同样是进行加密,用加密后的RSA密钥对对随机字符串i进行加密</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// f=&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;\</span></span><br><span class="line"><span class="comment">//    g=&#x27;0CoJUm6Qyw8W8jud&#x27;</span></span><br><span class="line"><span class="comment">//    e=&#x27;01001&#x27;</span></span><br><span class="line"><span class="comment">//    d=tostring(data),e=bsR5W([&quot;流泪&quot;, &quot;强&quot;]),也即`01001`,f=bsR5W(Xp0x.md),g=bsR5W([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">d, e, f, g</span>) </span>&#123;    <span class="comment">// 产生加密的函数  此处的唯一变动实际上是d的值,也就是取决于data的内容</span></span><br><span class="line">        <span class="keyword">var</span> h = &#123;&#125;</span><br><span class="line">          , i = a(<span class="number">16</span>);          <span class="comment">// 产生16个随机字符</span></span><br><span class="line">        <span class="keyword">return</span> h.encText = b(d, g),</span><br><span class="line">        h.encText = b(h.encText, i),    <span class="comment">// 也就是对数据内容进行两次加密,第一次加密使用的密钥为固定值g</span></span><br><span class="line">                                        <span class="comment">// 第二次加密使用的密钥为随机数i</span></span><br><span class="line">        h.encSecKey = c(i, e, f),</span><br><span class="line">        h</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">a, b, d, e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> f = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> f.encText = c(a + e, b, d),</span><br><span class="line">        f</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.asrsea = d, <span class="comment">// asrsea函数的真正本体</span></span><br><span class="line">    <span class="built_in">window</span>.ecnonasr = e</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time      : 2022/3/19 10:34</span></span><br><span class="line"><span class="comment"># @Author    : Baxkiller</span></span><br><span class="line"><span class="comment"># @File      : netease_music163_comments.py</span></span><br><span class="line"><span class="comment"># @Software  : PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span>(<span class="params">strs</span>):</span></span><br><span class="line">    l = <span class="number">16</span> - (<span class="built_in">len</span>(strs) % <span class="number">16</span>)</span><br><span class="line">    strs += <span class="built_in">chr</span>(l) * l</span><br><span class="line">    <span class="keyword">return</span> strs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;rid&quot;</span>: <span class="string">&quot;R_SO_4_1306923998&quot;</span>,</span><br><span class="line">    <span class="string">&quot;threadId&quot;</span>: <span class="string">&quot;R_SO_4_1306923998&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageNo&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pageSize&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cursor&quot;</span>: <span class="string">&quot;-1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;orderType&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = <span class="string">&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;</span></span><br><span class="line">g = <span class="string">&quot;0CoJUm6Qyw8W8jud&quot;</span></span><br><span class="line">e = <span class="string">&#x27;01001&#x27;</span></span><br><span class="line">i = <span class="string">&quot;GAmFwie2XTGvncAy&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encSecKey</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;23ffcf188f9a56c6917dc47e8ff9c07f1837723ed57ed45d639e182c387c57293ccd37c3e0e20603a7818456b3e4730be3a429187129fedf600851d0b7d74db24916a2f47693a3a6cb95f502d2b4d6dcb1db78fa59f4fc0bfaf8cf5d999b4eaf9ab0a0506876449a8bff2d6530ace6c00bcf8ea80d3db7bd9b7cdee640c6ca02&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对传入的字符串进行加密</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encWords</span>(<span class="params">strs, key</span>):</span></span><br><span class="line">    iv = <span class="string">&quot;0102030405060708&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    strs = padding(strs)  <span class="comment"># 先填充padding</span></span><br><span class="line">    strs = strs.encode(<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 再进行编码</span></span><br><span class="line">    key = key.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    cryptos = AES.new(key = key, iv = iv, mode = AES.MODE_CBC)  <span class="comment"># 创建加密</span></span><br><span class="line">    res = cryptos.encrypt(strs)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(base64.b64encode(res), <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">strs</span>):</span></span><br><span class="line">    res = encWords(strs, g)</span><br><span class="line">    res = encWords(res, i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url = <span class="string">&quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;</span></span><br><span class="line">    datas = &#123;</span><br><span class="line">        <span class="string">&quot;params&quot;</span>: get_params(json.dumps(data)),</span><br><span class="line">        <span class="string">&quot;encSecKey&quot;</span>: get_encSecKey()</span><br><span class="line">    &#125;</span><br><span class="line">    resp = requests.post(url = url, data = datas)</span><br><span class="line">    <span class="built_in">print</span>(resp.json())</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="成功结果"><a href="#成功结果" class="headerlink" title="成功结果"></a>成功结果</h2><p><img src="https://s2.loli.net/2022/03/19/wcoSBGtF35vrNsq.png" alt="image-20220319173436731"></p>
<p>​    </p>
]]></content>
      <tags>
        <tag>SELF_LEARNING</tag>
      </tags>
  </entry>
  <entry>
    <title>Compile_Principle_Review</title>
    <url>/2022/06/14/Compile-Principle-Review/</url>
    <content><![CDATA[<h2 id="概念题-不考"><a href="#概念题-不考" class="headerlink" title="概念题(不考"></a>概念题(不考</h2><ul>
<li><p><input disabled="" type="checkbox">  什么是编译程序</p>
<p>翻译程序:</p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  表达式得形成规则</p>
<p>➢ 变量（包括下标变量）、常数是<strong>表达式</strong>；</p>
<p>➢ 若E1、E2为表达式，θ是一个二元算符，则$E_1\ θ\ E_2$是一个表达式；</p>
<p>➢ 若E是表达式，θ为一元算符，则$θE（或Eθ）$是表达式；</p>
<p>➢ 若E是表达式，则(E)是表达式。</p>
</li>
<li><p><input disabled="" type="checkbox">  运算顺序和结合性(关于<strong>运算符优先级</strong>的知识)</p>
</li>
<li><p><strong>闭包</strong></p>
<p>某个符号串的闭包运算规则是,但是经过的是有限次的链接而成的,也就是闭包中的每个字符串的长度有限.<br>$$<br>V^{<em>}=V^{0} \or V^{1} \or V^{2} \or V^{3} \or \cdots<br>$$<br><strong>正则闭包</strong><br>$$<br>V^{+}=VV^{</em>}<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  关于空集与空字的区分!</p>
<p>空集,即$\varnothing$,代表的是${}$,是集合</p>
<p>空字,用$\epsilon$表示,代表的是不含有任何符号的序列,是一个集合中的元素</p>
<p>而${\epsilon}$往往用来代表某个符号串的0次连接积,也就是$V^{0}$</p>
</li>
</ul>
<ul>
<li><p><strong>关于推导</strong></p>
<p>最右推导: 推导过程中,总是最先替换最右的非终结符,称之为<strong>最右推导</strong></p>
<p>最右规约:规约时,总是最先规约最右的非终结符,称之为最右规约.</p>
<p><strong>规范推导(最右推导)</strong></p>
<p><strong>规范规约(最左规约)</strong></p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  知道常见的状态转换图</p>
</li>
<li><p><input disabled="" type="checkbox">  正规式之间的运算规则以及常见的等价正规式</p>
<ul>
<li><p>等价的正规式    </p>
<p>例如比较常见的是b(a|b)^<em>^=(ba)^</em>^b  , (a|b)^<em>^=(a^</em>^b^<em>^)^</em>^</p>
</li>
<li><p>常用的正规式</p>
<img src="https://s2.loli.net/2022/06/14/4bjIEawFm3APiQG.png" alt="image-20220612141509718" style="zoom:80%;" /></li>
<li><p>正规式运算规则</p>
<p>连接不满足交换律.</p>
<img src="https://s2.loli.net/2022/06/14/keN8bymAXfIVUiL.png" alt="image-20220612141624199" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <strong>关于自上而下的分析方法存在的问题</strong><ul>
<li>可能存在的左递归导致的无线循环</li>
<li>分析过程成,多个候选式导致的回溯,产生一定的开销</li>
<li>虚假匹配问题</li>
<li>使用自上而下的语法分析无法确定具体的出错位置</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  属性文法的杂碎知识</p>
<ul>
<li><p>语义规则</p>
<p>语义规则的形式为$b=f(c_1,c_2,\cdots,c_k)$ </p>
</li>
<li><p>综合属性</p>
<p>综合属性来源于产生式右边的文法符号的属性</p>
<blockquote>
<p>终结符只有综合属性,由词法分析器来提供</p>
<p><strong>只使用综合属性的文法称为S-属性文法.</strong></p>
<p>通常通过自底向上的方法计算综合属性值.</p>
</blockquote>
</li>
<li><p>继承属性</p>
<p>继承属性是指产生式右边的文法符号的某个属性,是取决于其兄弟节点后者产生式左侧的非终结符的属性</p>
<blockquote>
<p>文法开始符号的所有继承属性作为属性计算前的初始值</p>
</blockquote>
</li>
<li><p><strong>语法制导翻译</strong>(软院往年考过!)</p>
<blockquote>
<p><strong>由源程序的语法结构所驱动的处理方法,称为语法制导翻译.</strong></p>
<p>其语义规则计算可能会产生代码\在符号表中存放信息\给出错误信息\执行<strong>任何其他动作</strong>.</p>
</blockquote>
<blockquote>
<p>为文法的每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则，完成有关语义分析和代码生成的工作。</p>
<p>➢ 在<strong>自上而下</strong>的分析中，当一个产生式<strong>匹配输入串成功时执行</strong>；</p>
<p>➢ 在<strong>自下而上</strong>的分析中，当一个<strong>产生式被用于归约时执行</strong>。</p>
</blockquote>
</li>
<li><p>依赖图</p>
<p>如果一个节点的属性b依赖于属性c,则从c绘制向b的有向边.</p>
<p>注意,这里的节点不是文法符号,而是每个文法符号的每个属性.</p>
</li>
<li><p>一遍扫描的处理方法</p>
</li>
<li><p>S-属性文法（只使用综合属性）</p>
<p>其属性的计算遵循从下到上的计算方法，通常借助<strong>LR分析器</strong>实现。表现为在LR分析器的【状态栈 | 符号栈】的符号栈中添加符号的属性值。</p>
</li>
<li><p>L-属性文法</p>
<blockquote>
<p>概念：如果对于每个产生式𝐴 → 𝑋1𝑋2 … 𝑋𝑛，其语义规则中的每个属性或者是综合属性，或者是𝑋𝑖(1 ≤ 𝑖 ≤ 𝑛)的一个继承属性且这个继承属性仅依赖于：</p>
<p>➢ 产生式右部𝑋𝑖 的<strong>左边符号</strong>𝑋1, 𝑋2, … , 𝑋𝑖−1的属性； </p>
<p>➢ 产生式左部𝐴的继承属性。 </p>
</blockquote>
<p>S属性文法一定是L属性文法。可以采用自上而下的翻译，也可以采用自下而上的翻译。</p>
</li>
<li><p>翻译模式的设计：</p>
<ul>
<li><p>自上而下</p>
<p>对于既有综合属性又有继承属性的情况：</p>
<p>① 产生式右部符号的继承属性，必须在这个符号以前的动作中计算出来；</p>
<p>② 一个动作不能引用这个动作右边符号的综合属性； </p>
<p>③ 产生式左部的𝑉𝑁的综合属性，只有在它所引用的所有属性都计算出来以后才能计算（放到右边末尾）。</p>
</li>
<li><p>自下而上</p>
<p>要求语义动作放在产生式末尾</p>
<p>解决方案：引入空符号产生式（只需要处理动作，不需要处理属性计算）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="可能会考到"><a href="#可能会考到" class="headerlink" title="可能会考到"></a><strong>可能会考到</strong></h2><ul>
<li><p><input disabled="" type="checkbox">  对于<strong>上下文无关文法的定义</strong>和一些约定</p>
<p>具体概念表示为:<strong>它所定义的文法范畴（或语法单位）是完全独立于这种范畴可能出现的环境的。</strong></p>
<p>通过一个四元式进行定义:<br>$$<br>G=(V_T,V_N,S,P)<br>$$<br>其中从前到后的意义分别是:</p>
<p>终结符号\非终结符号\开始符号\ <strong>产生式集合</strong></p>
<p>其中产生式集合中元素的形式如下:<br>$$<br>P\rarr \alpha<br>$$<br>其中的P是属于非终结符号,\alpha属于<strong>非终结符号与终结符号的闭包.</strong></p>
<p><strong>一些约定内容:</strong></p>
<p>使用<strong>大写字母</strong>代表非终结符</p>
<p>使用<strong>小写字母</strong>代表终结符</p>
<p>使用<strong>希腊字母</strong>代表终结符和非终结符组成的字符串.</p>
<p><strong>对于语言的描述</strong>: 使用一种形式将文法G所产生的句子的全体是一个语言,表示为<strong>集合的形式</strong><br>$$<br>L(G)={a|S<br>\stackrel{+}{\Rarr}<br>\alpha }<br>$$<br>或者也可以使用描述的方式进行书写.</p>
</li>
</ul>
<ul>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox">  正规式到正规文法的改写规则以及正规文法的概念</p>
<ul>
<li><p>正规式的递归定义</p>
<img src="https://s2.loli.net/2022/06/14/SrRUMTVdJKWEXnc.png" alt="image-20220612152430625" style="zoom:80%;" /></li>
<li></li>
</ul>
<img src="https://s2.loli.net/2022/06/14/1TFi89LaJdQwSVu.png" alt="image-20220612142039208" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/06/14/BgwJ8lN36oPzxWO.png" alt="image-20220612142210536" style="zoom:50%;" /></li>
<li><p><input disabled="" type="checkbox">  翻译句子相关的知识点</p>
<ul>
<li><p>后缀式</p>
</li>
<li><p>三地址代码(例如X=A+B) 四元式</p>
</li>
<li><p>说明语句的翻译  例如<code>int a,b;</code> 应该得到的名字表中应存储<code>a,b:int</code> (符号表的填写)</p>
<img src="https://s2.loli.net/2022/06/15/7LpoxVv9K4XyFDl.png" style="zoom:80%;" /></li>
<li><p>int与real的转换? 课后题</p>
</li>
<li><p>布尔表达式和控制条件?</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> 运行时空间组织PPT</li>
</ul>
<h2 id="必考知识点"><a href="#必考知识点" class="headerlink" title="必考知识点"></a>必考知识点</h2><ul>
<li><p><strong>画图表示编译过程的各阶段</strong></p>
<img src="https://s2.loli.net/2022/06/14/F5u84fbTcx62qQa.png" alt="image-20220610232132366" style="zoom:67%;" />

<p>或许有可能要我们<strong>解释这个图的具体含义?</strong></p>
<ul>
<li><p><strong>词法分析器:</strong></p>
<p>又称<strong>扫描器</strong>,输入源程序,从左到右逐个字符地对源程序扫描,进行词法分析,输出单词符号.</p>
</li>
<li><p><strong>语法分析器:</strong></p>
<p>又称分析器，对单词符号串进行语法分析，识别出各类语法单位，最终判断输入串是否构成语法上正确的“程序”。</p>
</li>
<li><p><strong>语义分析和中间代码生成器:</strong></p>
<p>按照语义规则对语法分析器归约（或推导）出的语法单位进行语义分析，并把它们翻译成一定形式的<strong>中间代码</strong>。</p>
</li>
<li><p><strong>优化器:</strong></p>
<p>对中间代码进行优化处理</p>
</li>
<li><p><strong>目标代码生成器:</strong></p>
<p>把中间代码翻译成目标代码。</p>
</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox">  二义文法</p>
<ul>
<li><p>概念</p>
<p>如果一个文法的某个句子对应两棵不同的语法树，<strong>即其最左（最右）推导不唯一</strong>，称该文法为二义文法。</p>
</li>
<li><p>文法的二义性与语言的二义性是不同的概念.</p>
<p>具体而言:</p>
<ul>
<li>可能存在两个不同的文法G和G’,其中一个是二义的,一个是无二义的,但是有L(G)=L(G’);</li>
<li>对于一个语言,我们常常希望其文法是无二义的,因为我们希望对它每个语句的分析是唯一的；</li>
</ul>
</li>
<li><p>考点</p>
<p>证明某个文法是二义的,具体需要自己找出一个例子,推导出两棵不同的语法树.</p>
</li>
<li><p>求解</p>
<p><strong>(优先级越高越远离开始符号)</strong></p>
</li>
<li><p>例题</p>
<p>𝐸 → 𝐸 + 𝐸 | 𝐸 ∗ 𝐸 | (𝐸) | 𝑖，构造该文法的无二义文法，使它们表示的语言相同，并给出句子 i*i+i的最右推导。</p>
<img src="https://s2.loli.net/2022/06/14/nX2BCMYvtqpT3Em.png" alt="image-20220611235922378" style="zoom:67%;" /></li>
</ul>
</li>
<li><p><strong>形式语言</strong></p>
<p>相关的形式语言了解.</p>
<ul>
<li><p>0型文法(限制最宽松,常见的都是0型),对应0型语言都是递归可枚举的,能力相当于图灵机,半可判定</p>
<img src="https://s2.loli.net/2022/06/14/jdqasSA4r1uyzBn.png" alt="image-20220612004714652" style="zoom: 80%;" /></li>
<li><p>1型文法,又被称之为<strong>上下文有关文法</strong>.线性有界自动机.在0型文法基础之上的每个$\alpha \rarr \beta$ ,都有$|\beta| \ge |\alpha|$ ,即由小生大, ($S \rarr \epsilon $ 除外),且S不能出现在产生式的右部.</p>
<p>$L(G)={a^nb^nc^n | n\ge 1}$只能由本文法产生</p>
</li>
<li><p>2型文法,又称为<strong>上下文无关文法</strong>,对应下推自动机.使用下推表(先进后出栈)的有限自动机是分析的基本手段.满足条件为,在0型基础之上,满足$𝐴 → 𝛽, 𝐴 ∈ 𝑉_𝑁, 𝛽 ∈ (𝑉_𝑁 ∪ 𝑉_𝑇 )^*$</p>
<p>可以产生S-&gt;aSb | ab</p>
</li>
<li><p>3型文法,又称<strong>右线性文法/左线性文法</strong>.等价于正规式,所以也称为正规文法.在0型基础之上,满足:$𝐴 → 𝛼𝐵或𝐴 → 𝛼，其中，𝛼 ∈ 𝑉_𝑇^∗, 𝐴 ∈ 𝑉_𝑁,𝐵 ∈ 𝑉_N$.</p>
<p>不能产生语言a^n^b^n^</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><input checked="" disabled="" type="checkbox">  短语和句柄</p>
<ul>
<li><p>短语定义:</p>
<p>对文法𝐺[𝑆]，如果有$𝑆\stackrel{*}{\Rarr}𝛼𝐴𝛿$ 且 $𝐴 \stackrel{+}{\Rarr}𝛽$ ，则称𝛽是句型𝛼𝛽𝛿相对于非终结符号𝐴的短语。</p>
</li>
<li><p>直接短语</p>
<p>如果有$A\Rarr\beta$,称𝛽是句型𝛼𝛽𝛿相对于𝐴的<strong>直接短语</strong></p>
<p>通常对于直接短语的判断方式是通过对给定的句型,依照文法绘制对应的语法树。如果想要判断短语$\alpha$是不是直接短语，就看其父节点$A$的所有<strong>孩子节点</strong>（包含$\alpha$ 在内），是否都是<strong>叶子节点</strong>，如果是，则这里的叶子节点们组成的短语就是直接短语。</p>
</li>
<li><p>句柄</p>
<p>一个句型的<strong>最左直接短语</strong>称为该句型的句柄</p>
</li>
</ul>
</li>
<li><p><strong>FA写正规式</strong></p>
<p>根据自动机合并为正规式的方式,实际上是对正规式转化为非确定有限自动机的逆过程.</p>
<img src="https://s2.loli.net/2022/06/14/ObU3QqcZwIEmRur.png" alt="image-20220612185846837" style="zoom:67%;" /></li>
<li><p><input checked="" disabled="" type="checkbox">  消除左递归</p>
<p><strong>常见的</strong>/根本的措施就是通过添加非终结符:<br>$$<br>P \rarr P\alpha | \beta \<br>\Darr \<br>P \Rarr \beta \alpha ^*\<br>\Darr \<br>P\rarr \beta P’ \<br>P’ \rarr \alpha P’ | \epsilon<br>$$<br>利用正规式作为媒介,转换为右递归文法.</p>
<p>同样的道理,可以将上述内容进行推广.<br>$$<br>P\rarr P\alpha_1 | P\alpha_2|\cdots | P\alpha_n |\beta_1 | \beta_2 | \cdots|\beta_m \<br>\Darr\<br>P\rarr P(\alpha_1 | \alpha_2| \cdots| \alpha_n)|(\beta_1 | \beta_2| \cdots|\beta_m) \<br>\Darr \<br>P\rarr (\beta_1 | \beta_2| \cdots|\beta_m) P’ \<br>P’\rarr (\alpha_1 | \alpha_2| \cdots| \alpha_n)P’|\epsilon<br>$$</p>
<p>除了上述显示的左递归之外,还存在着隐式的左递归,对应于如果从A1推导到A2,那么绘制其对应的图中,节点A1和A2之间存在着一条有向边.</p>
<p>消除隐含左递归的方法就是:</p>
<pre><code>1. 给定一个非终结符号的排序,例如A1,A2 ... 
2. 保证每个推导公式中右侧的A_i的对应位置在左侧A_j的右侧.也就是必须从排序较小着推导到排序较大者.
3. 对满足第2条的,且包含了左递归的进行左递归消除.
</code></pre>
<p>如果想要使产生的产生式最少,那么:</p>
<blockquote>
<p>如果从开始符号获取到的值依次是A1,A2,…An,</p>
<p>那么排序时最好是按照这个顺序的逆序进行排列,即An,…,A2,A1</p>
<p><strong>????</strong></p>
</blockquote>
</li>
<li><p><input checked="" disabled="" type="checkbox">  提取公因子</p>
<p>目的就是消除回溯.</p>
<p>这里我们使用的提取左公因子的方法如下:<br>$$<br>P \rarr \alpha A_1 | \alpha A_2 | \cdots | \alpha A_n | \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr \<br>P\rarr \alpha (A_1 | A_2 |\cdots| A_n )| \beta_1 | \beta_2 |\dots|\beta_m \<br>\Darr\<br>P\rarr \alpha A | \beta_1 | \beta_2 |\dots|\beta_m \ ,\<br>A\rarr A_1 | A_2 |\cdots| A_n<br>$$</p>
</li>
<li><p><input disabled="" type="checkbox">  后缀表达式</p>
</li>
<li><p><input disabled="" type="checkbox">  符号表</p>
</li>
<li><p><input disabled="" type="checkbox">  运行时空间组织</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  静态链和动态链</p>
<p>这里主要是关于静态链内容的确定方式:</p>
<p>静态链内容填写分为三种情况:</p>
<ul>
<li><p>第N层调用第N+1层,也就相当于父亲节点调用孩子节点</p>
<p>第N+1层的静态链填写调用过程 ( 第 N层过程 ) 的最新活动记录的起始地址 .也就相当于被调用者的静态链=<strong>调用者的SP</strong></p>
</li>
<li><p>第N层调用第N层,相当于兄弟节点调用其对应的兄弟节点</p>
<p>被调用者的静态链内容填写为 调用过程 ( 第 N层过程 ) 的静态链的值。也就是被调用者静态链=<strong>调用者的静态链.</strong></p>
</li>
<li><p>第N层调用第N-X层</p>
<p>相当于第某一个后代节点调用其祖先节点.</p>
<p>被调用者的静态链填写需要<strong>沿着调用者的静态链跳转X次</strong>到达的活动记录的静态链内容,即被调用者的静态链内容.</p>
</li>
</ul>
</li>
</ul>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul>
<li><p><strong>词法分析,给定正规式</strong></p>
<blockquote>
<p>构造NFA<br>确定化<br>最小化</p>
</blockquote>
<h2 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h2><ul>
<li><p>经常用到的表现形式: <strong>状态转换图</strong></p>
<ul>
<li><p>使用<strong>结点表示状态</strong>,用<strong>圆圈</strong>表示</p>
</li>
<li><p>状态之间使用箭弧链接,上面的数字代表射出节点状态下可能出现的状态.</p>
</li>
<li><p>一张转换图只包含有限个状态,<strong>必然有一个为初态</strong>,<strong>至少有一个终态</strong>.</p>
</li>
<li><p><strong>初态要添加箭头</strong>指向表示,<strong>终态使用双圆圈</strong>表示.</p>
</li>
<li><p>注意到,如果判定时需要添加一个额外的符号来表示转换到终结态,那终结态应该还要退还这个多输入的额外的符号给输入串.使用<strong>终态节点上打星号</strong>代表多读入了一个不属于标识符的字符.</p>
<img src="https://s2.loli.net/2022/06/14/9ZLupBGYzcJRC6i.png" alt="image-20220612133236416" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><ul>
<li><p>什么是DFA</p>
<p>一个确定有限自动机使用五元式来表示 $M=(S,\Sigma,\delta,s_0,F)$</p>
<p>其中各个内容的含义:</p>
<ul>
<li><p>S: 一个有限集,每个元素代表一个状态</p>
</li>
<li><p>$\Sigma$: 有穷字母表,每个元素代表一个输入字符</p>
</li>
<li><p>$\delta$: 是从$S \times \Sigma$到$S$的单值映射,$\delta (s,a)=s’$代表当 当前状态为s,输入为a时,将转换到下一个状态s’, s’又被称为后继状态.</p>
</li>
<li><p>$s_0 \in S$, 代表<strong>唯一的初态</strong>.(<strong>确定有限自动机初态唯一</strong>)</p>
</li>
<li><p>$F\subseteq S$,是一个终态集,(<strong>可以为空集</strong>)</p>
</li>
</ul>
<p>综合来说,就是(状态集,输入集,转换关系,初态,终态集)</p>
</li>
<li><p>一个DFA可以表示为一张状态转换图(最左侧列代表状态),最上面行代表输入.</p>
<p>若M的初态结点同时又是终态结点，则空字𝜀可为M所识别（或接受）</p>
</li>
<li><p><strong>DFA的构造问题:给定一个正规式,将其转化DFA</strong></p>
</li>
<li><p>优缺点:</p>
<p>编程实现容易,效率高,但是构造困难</p>
</li>
</ul>
<h2 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h2><ul>
<li><p>关于非确定有限自动机NFA</p>
<p>基本同上,同样使用五元式进行表示,不过不同的是:</p>
<ul>
<li><p>原本的$\delta$代表的单值映射,这里是$S \times \Sigma^* 到S$的<strong>子集</strong>的映射.也就是<br>$$<br>\delta:S \times \Sigma^{*} \rarr 2^{S}<br>$$</p>
</li>
<li><p>原本的初态是唯一的,这里的初态是<strong>非空初态集</strong></p>
</li>
<li><p>另外,在这里的弧上可以出现空字**$\epsilon$**</p>
</li>
</ul>
</li>
<li><p><strong>从一个正规式转化为NFA</strong></p>
</li>
<li><p><strong>给定一个NFA,如何将其转化为正规式</strong></p>
</li>
<li><p>优缺点</p>
<p>NFA构造比较容易,但是编程实现有回溯</p>
</li>
</ul>
<h2 id="NFA的确定化-转变为DFA"><a href="#NFA的确定化-转变为DFA" class="headerlink" title="NFA的确定化(转变为DFA)"></a>NFA的确定化(转变为DFA)</h2><ul>
<li><p>使得初态和终态唯一(引入新的初态X和终态Y).</p>
<p>从𝑋 到𝑆0 的任意状态结点连一条𝜀箭弧；</p>
<p>从𝐹中的任意状态结点连一条𝜀箭弧到𝑌。</p>
</li>
<li><p>分裂</p>
<p>使得每条箭弧上或为$\epsilon$ ,或者是$\Sigma$中的单个字符</p>
<img src="https://s2.loli.net/2022/06/14/azZdQeVgf3Kbnos.png" alt="image-20220612160632690" style="zoom:67%;" /></li>
<li><p>寻找可合并状态</p>
<p>引入闭包的概念,定义I的ε闭包ε_Closure(I)为：</p>
<p>➢ 若𝑞 ∈ 𝐼，则𝑞 ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)； </p>
<p>➢ 若𝑞 ∈ 𝐼, 𝛿(𝑞, 𝜀) = 𝑞′，则𝑞′ ∈ 𝜀_𝐶𝑙𝑜𝑠𝑢𝑟𝑒(𝐼)。(也即是从闭包内的状态接受空字可以转移到的状态)</p>
<p><strong>具体过程步骤:</strong></p>
<img src="https://s2.loli.net/2022/06/14/YwEpAqB8FsrJCRW.png" alt="image-20220612161011278" style="zoom:67%;" /></li>
<li><p>状态合并</p>
<p>➢ 每个状态子集视为新的状态； </p>
<p>➢ <strong>初态为首行首列；</strong> (而不是含有初态的就是初态!)</p>
<p>➢ <strong>终态是含有原终态的状态子集。</strong></p>
</li>
</ul>
<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2><ul>
<li><p>定义等价状态</p>
<ul>
<li><p>如果从𝑠出发能读出某个字𝑤而停在终态，那么从𝑡出发也能读出字𝑤停在终态；</p>
</li>
<li><p>如果从𝑡出发能读出某个字𝑤而停在终态，那么从𝑠出发也能读出字𝑤停在终态。</p>
</li>
</ul>
</li>
<li><p>可区别状态</p>
<ul>
<li>终态和非终态 可区别的</li>
<li>射出弧不同(一个有a,一个没有a) 可区别的</li>
<li>通过同样的输入得到的输出是可区别的  可区别的</li>
<li>通过某个输入到达的状态及其等价状态,对另一个来说使用某个输入是不可到达的  可区别的</li>
</ul>
</li>
<li><p>化简时,首先从<strong>终态与非终态的区分</strong>开始</p>
<p>每次都要检查原本同一个集合中的元素得到相同的输入后的输出是否在同一个集合中.如果不,将两者剥离.</p>
</li>
<li><p>化简后的弧的创建:</p>
<img src="https://s2.loli.net/2022/06/14/e9wCyIgutAvmrJY.png" alt="image-20220612171255023" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><ul>
<li><p><strong>LL(1)分析,给出文法</strong></p>
<blockquote>
<p>构造First集合<br>否则Follow集合<br>构造LL(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>LL(1)文法中<strong>最重要的两个概念</strong>:</p>
<ul>
<li>终结首符集 (头符号集)</li>
<li>后继终结符号集(后继符号集)产生原因在于对空字进行匹配时,需要依据这里的判断来决定是否要进行匹配.</li>
</ul>
<p>进行LL(1)分析时,需要满足的条件如下,满足以下条件,才称之为LL(1)文法:</p>
<blockquote>
<p>L: From <code>L</code>eft to Right</p>
<p>L: 最左推导</p>
<p>1: 分析一步,看右侧的一个符号</p>
</blockquote>
<ul>
<li>文法不含左递归；  –<code>不含有左递归</code></li>
<li>对𝐴 → 𝛼1| … |𝛼𝑛的每对候选式，有𝐹𝑖𝑟𝑠𝑡 (𝛼𝑖) ∩ 𝐹𝑖𝑟𝑠𝑡(𝛼𝑗) = ∅，其中𝑖 ≠ 𝑗；  <code>同一个推导式的右侧首符集无公用元素</code></li>
<li>对非终结符号𝐴，若𝜀 ∈ 𝐹𝑖𝑟𝑠𝑡(𝐴)，有𝐹𝑖𝑟𝑠𝑡 (𝐴) ∩ 𝐹𝑜𝑙𝑙𝑜𝑤 (𝐴) = ∅。 <code>同一个非终结符的首符集与后继符号集不相交</code></li>
</ul>
<p>分析时:</p>
<img src="https://s2.loli.net/2022/06/14/5M6sg8SJtnvGRap.png" alt="image-20220614093624431" style="zoom:67%;" />



<p><strong>First集合的求解:</strong></p>
<img src="https://s2.loli.net/2022/06/14/GE6m7nKSahcukLA.png" alt="image-20220614093824988" style="zoom:80%;" />

<p>向首符集中添加空字\epsilon的条件: </p>
<ul>
<li>明确说明了从X能直接推导 epsilon</li>
<li>对于X推导出的某一串连续的非终结符,这一串非终结符都含有空字epsilon</li>
</ul>
<p>对于<strong>Follow集合</strong>:</p>
<ul>
<li><p>特别地一个终结符<code>#</code>,在S所在的推导式的右侧添加<code>#</code>,进而为对应的非终结符提供Follow集合中的<code>#</code></p>
</li>
<li><p>具体求解</p>
<img src="https://s2.loli.net/2022/06/14/jEIOKosknHblWA1.png" alt="image-20220614094603428" style="zoom:80%;" /></li>
</ul>
<p><strong>构造LL(1)分析表</strong></p>
<img src="https://s2.loli.net/2022/06/14/cOg9BvlFPeHo2S4.png" alt="image-20220614095418380" style="zoom:80%;" />

<p>表格的格式如下所示:</p>
<table>
<thead>
<tr>
<th></th>
<th>$V_{T1}$</th>
<th>$V_{T2}$</th>
<th>$\cdots$</th>
<th>#</th>
</tr>
</thead>
<tbody><tr>
<td>$V_{N1}$</td>
<td></td>
<td></td>
<td></td>
<td><strong>千万不要忘记!</strong></td>
</tr>
<tr>
<td>$V_{N2}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$V_{N3}$</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>分析过程</strong></p>
<img src="https://s2.loli.net/2022/06/14/2T7zDNJRMOHaklq.png" alt="image-20220614095609097" style="zoom: 80%;" />

<p>进行分析时的表格格式如下所示:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>文法符号栈</th>
<th>输入串</th>
<th>所用产生式</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h3><ul>
<li><p><strong>LR分析,给出文法</strong></p>
<blockquote>
<p>构造拓广文法<br>构造拓广文法的LR(0)/LR(1)项目集规范族<br>构造LR(0)/LR(1)分析表（可能涉及消除二义文法冲突）<br>识别句子</p>
</blockquote>
<p>分析法的优点:</p>
<ul>
<li>多数上下文无关文法描述的语言都可以使用LR分析器识别.</li>
<li>LR能分析的文法包括LL(1)能分析的文法.</li>
<li>扫描输入串时可以发现任何错误,并能准确指出出错地点.</li>
</ul>
<p>常见的LR分析四种方法包括:</p>
<ul>
<li>LR(0)分析法,局限性大</li>
<li>简单LR(SLR)</li>
<li>规范LR</li>
<li>向前LR(LALR)</li>
</ul>
<h3 id="定义LR文法以及相关概念"><a href="#定义LR文法以及相关概念" class="headerlink" title="定义LR文法以及相关概念"></a>定义LR文法以及相关概念</h3><ul>
<li><p>LR文法:文法能够构造一个LR分析表,使得其每一个入口都唯一</p>
</li>
<li><p>规范句型: 包含句柄的可规约句型</p>
</li>
</ul>
<h3 id="LR（0）分析法"><a href="#LR（0）分析法" class="headerlink" title="LR（0）分析法"></a>LR（0）分析法</h3><p>需要注意一点: $A\rarr \epsilon$只有一个状态$A\rarr \dot{}$</p>
<p>分析过程:</p>
<ol>
<li><p>首先构造拓广文法</p>
<p>也就是$G_1=(V_T,V_N,S,P)$构造为$G_2=(V_T,V_N ∪{S’},S’,P∪{S’ \rarr S})$</p>
<p>我们称G2是G1的拓广文法.</p>
</li>
<li><p>构造拓广文法的LR(0)项目集规范族</p>
<p>这里需要使用到闭包的相关概念.</p>
</li>
<li><p>构造分析表</p>
</li>
<li><p>识别句子</p>
</li>
</ol>
<p>认为SLR与LR(1)的主要区别在于:</p>
<p>SLR避免冲突的方式,是对整个文法中每个非终结符求取其对应的FOLLOW集合内容,从而得到对应的后继终结符,根据决定规约/移进时,对应规约式规约后的非终结符的FOLLOW集合中是否含有下一个要移入的终结符来判断是否选择规约.</p>
<p>而LR(1)的方法相较于SLR更加细化,也就是其根据的不是宽泛的整个语法中的FOLLOW集合,而是单纯根据对应推导式的FOLLOW集合,具体是指对应<code>·</code>所在的位置后面,看作一个整体,看其整体的FIRST集合.</p>
<p>三者的差别反映在分析表的构造上:</p>
<ul>
<li><p>对于LR(0),如果<code>·</code>到达了式子的末尾,那么对应在分析表的所有终结符对应位置都要填写规约式.</p>
</li>
<li><p>对于SLR,只在规约后的非终结符的FOLLOW对应的终结符的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/SOoJrq8fWihBDCK.png" alt="image-20220614223033464"></p>
</li>
<li><p>对于LR(1),在对应<code>·</code>在式子末尾时,式子的<code>前瞻符号</code>的位置填写规约式.</p>
<p><img src="https://s2.loli.net/2022/06/14/QAOpidHvRF6oqnD.png" alt="image-20220614223001637"></p>
</li>
</ul>
</li>
</ul>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><ul>
<li><p><strong>给出翻译模式和高级语言程序，翻译句子</strong></p>
<blockquote>
<p>一般涉及多种类型句子的综合，也可能涉及声明语句填写符号表。</p>
</blockquote>
</li>
</ul>
<h3 id="DAG优化"><a href="#DAG优化" class="headerlink" title="DAG优化"></a>DAG优化</h3><ul>
<li><p><strong>给出基本代码块</strong></p>
<blockquote>
<p><strong>对于给定的基本块构造DAG</strong></p>
<p><strong>按照构造DAG的节点顺序重新写中间代码</strong></p>
<p><strong>利用节点排序算法对节点排序,并根据排序后的节点顺序写中间代码</strong></p>
<p><strong>对上一步的中间代码利用简单代码生成算法生成目标代码</strong></p>
<blockquote>
<p>写出优化后的中间代码<br>写出DAG目标优化后的中间代码<br>根据变量活跃性和寄存器信息，写出目标代码</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul>
<li><p>构造语言</p>
<p>给出语言$L(G)={a^{m}b^{n}|1&lt;=n&lt;=m&lt;=2n}$,  请构造对应文法.</p>
<p>答:<br>$$<br>G(S):\<br>S=ab | aab\<br>S=aSb | aaSb<br>$$</p>
</li>
<li><p>作业题</p>
<img src="https://s2.loli.net/2022/06/14/oYXO7H5rIswWVJm.png" alt="image-20220612004824158" style="zoom:67%;" /></li>
</ul>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3>]]></content>
  </entry>
</search>
